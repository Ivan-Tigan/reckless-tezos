(window.webpackJsonp=window.webpackJsonp||[]).push([[207],{281:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return r})),a.d(t,"metadata",(function(){return l})),a.d(t,"toc",(function(){return p})),a.d(t,"default",(function(){return m}));var n=a(3),i=a(7),o=(a(0),a(457)),c=a(459),s=a(464),r={id:"current-reference",title:"Tezos",description:"General operations for Tezos",hide_table_of_contents:!0},l={unversionedId:"reference/current-reference",id:"version-0.25.0/reference/current-reference",isDocsHomePage:!1,title:"Tezos",description:"General operations for Tezos",source:"@site/versioned_docs/version-0.25.0/reference/current.md",slug:"/reference/current-reference",permalink:"/docs/reference/current-reference",version:"0.25.0",sidebar:"version-0.25.0/docs",previous:{title:"String",permalink:"/docs/reference/string-reference"},next:{title:"Test",permalink:"/docs/reference/test"}},p=[{value:"Examples",id:"examples",children:[]},{value:"Linearity",id:"linearity",children:[]}],b={toc:p};function m(e){var t=e.components,a=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},b,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"const balance : tez"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val balance : tez"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let balance: tez"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let balance: tez"),Object(o.b)("p",null,"Get the balance for the contract."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),"function main (const p : unit; const s: tez) : list (operation) * tez is\n  ((nil : list (operation)), Tezos.balance)\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),"let main (p,s : unit * tez) = ([] : operation list), Tezos.balance\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),"let main = ((p,s) : (unit, tez)) =>\n  ([]: list (operation), Tezos.balance);\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),"let main = ([p, s] : [unit, tez]):[list<operation>, tez] =>\n  [(list([]) as list<operation>), Tezos.balance];\n"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"const now : timestamp"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val now : timestamp"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let now: timestamp"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let now: timestamp"),Object(o.b)("p",null,"Returns the current time as a ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Unix_time"}),"UNIX timestamp"),"."),Object(o.b)("p",null,"In LIGO, timestamps are type compatible in operations with\nintegers. This lets you set for instance time constraints for your\nsmart contracts like this:"),Object(o.b)("h3",{id:"examples"},"Examples"),Object(o.b)("h4",{id:"24-hours-from-now"},"24 hours from now"),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=b",group:"b"}),'const today: timestamp = Tezos.now;\nconst one_day: int = 86_400;\nconst in_24_hrs: timestamp = today + one_day;\nconst some_date: timestamp = ("2000-01-01T10:10:10Z" : timestamp);\nconst one_day_later: timestamp = some_date + one_day;\n'))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=b",group:"b"}),'let today: timestamp = Tezos.now\nlet one_day: int = 86_400\nlet in_24_hrs: timestamp = today + one_day\nlet some_date: timestamp = ("2000-01-01t10:10:10Z" : timestamp)\nlet one_day_later: timestamp = some_date + one_day\n'))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=b",group:"b"}),'let today: timestamp = Tezos.now;\nlet one_day: int = 86_400;\nlet in_24_hrs: timestamp = today + one_day;\nlet some_date: timestamp = ("2000-01-01t10:10:10Z" : timestamp);\nlet one_day_later: timestamp = some_date + one_day;\n'))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=b",group:"b"}),'let today: timestamp = Tezos.now;\nlet one_day: int = 86_400;\nlet in_24_hrs: timestamp = today + one_day;\nlet some_date: timestamp = ("2000-01-01t10:10:10Z" as timestamp);\nlet one_day_later: timestamp = some_date + one_day;\n'))),Object(o.b)("h4",{id:"24-hours-ago"},"24 hours ago"),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=c",group:"c"}),"const today: timestamp = Tezos.now;\nconst one_day: int = 86_400;\nconst in_24_hrs: timestamp = today - one_day;\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=c",group:"c"}),"let today: timestamp = Tezos.now\nlet one_day: int = 86_400\nlet in_24_hrs: timestamp = today - one_day\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=c",group:"c"}),"let today: timestamp = Tezos.now;\nlet one_day: int = 86_400;\nlet in_24_hrs: timestamp = today - one_day;\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=c",group:"c"}),"let today: timestamp = Tezos.now;\nlet one_day: int = 86_400;\nlet in_24_hrs: timestamp = today - one_day;\n"))),Object(o.b)("h4",{id:"comparing-timestamps"},"Comparing Timestamps"),Object(o.b)("p",null,"You can also compare timestamps using the same comparison operators as\nfor numbers"),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=c",group:"c"}),"const not_tommorow: bool = (Tezos.now = in_24_hrs)\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=c",group:"c"}),"let not_tomorrow: bool = (Tezos.now = in_24_hrs)\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=c",group:"c"}),"let not_tomorrow: bool = (Tezos.now == in_24_hrs);\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=c",group:"c"}),"let not_tomorrow: bool = (Tezos.now == in_24_hrs);\n"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"const amount : tez"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val amount : tez"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let amount: tez"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let amount: tez"),Object(o.b)("p",null,"Get the amount of tez provided by the sender to complete this\ntransaction."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),"function threshold (const p : unit) : int is\n  if Tezos.amount = 100tz then 42 else 0\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),"let threshold (p : unit) : int = if Tezos.amount = 100tz then 42 else 0\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),"let threshold = (p : unit) : int =>\n  if (Tezos.amount == 100tz) { 42; } else { 0; };\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),"let threshold = (p : unit) : int => {\n  if (Tezos.amount == (100 as tez)) { return 42; } else { return 0; };\n};\n"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"const sender : address"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val sender : address"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let sender: address"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let sender: address"),Object(o.b)("p",null,"Get the address that initiated the current transaction."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),"function main (const p : unit) : address is Tezos.sender\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),"let main (p: unit) : address = Tezos.sender\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),"let main = (p : unit) : address => Tezos.sender;\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),"let main = (p : unit) : address => Tezos.sender;\n"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function address : contract 'a -> address"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val address : 'a contract -> address"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let address: contract('a) => address"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let address: (contract: contract<'a>) => address"),Object(o.b)("p",null,"Get the address associated with a value of type ",Object(o.b)("inlineCode",{parentName:"p"},"contract"),"."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),"function main (const p : key_hash) : address is block {\n  const c : contract (unit) = Tezos.implicit_account (p)\n} with Tezos.address(c)\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),"let main (p : key_hash) =\n  let c : unit contract = Tezos.implicit_account p\n  in Tezos.address c\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),"let main = (p : key_hash) : address => {\n  let c : contract (unit) = Tezos.implicit_account (p);\n  Tezos.address (c);\n};\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),"let main = (p : key_hash): address => {\n  let c: contract<unit> = Tezos.implicit_account(p);\n  return Tezos.address(c);\n};\n"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"const self_address : address"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val self_address : address"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let self_address: address"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let self_address: address"),Object(o.b)("p",null,"Get the address of the currently running contract."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),"function main (const p : unit) : address is Tezos.self_address\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),"let main (p : unit) : address = Tezos.self_address\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),"let main = (p : unit) : address => Tezos.self_address;\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),"let main = (p : unit): address => Tezos.self_address;\n"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function self : string -> contract 'a"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val self : string -> 'a contract"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let self: string => contract('a)"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let self: (entrypoint: string) => contract<'a>"),Object(o.b)("p",null,'Typecast the currently running contract with an entrypoint annotation.\nIf your are using entrypoints: use "%bar" for constructor Bar\nIf you are not using entrypoints: use "%default"'),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),'function main (const p : unit) : contract(unit) is block {\n  const c : contract(unit) = Tezos.self("%default") ;\n} with c\n'))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),'let main (p : unit) : unit contract =\n  (Tezos.self("%default") : unit contract)\n'))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),'let main = (p: unit) : contract(unit) =>\n  (Tezos.self("%default") : contract(unit));\n'))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),'let main = (p: unit) : contract<unit> =>\n  (Tezos.self("%default") as contract<unit>);\n'))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function implicit_account : key_hash -> contract 'a"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val implicit_account : key_hash -> 'a contract"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let implicit_account: key_hash => contract('a)"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let implicit_account: (hash: key_hash) => contract<'a>"),Object(o.b)("p",null,"Get the default contract associated with an on-chain key-pair. This\ncontract does not execute code, instead it exists to receive tokens on\nbehalf of a key's owner."),Object(o.b)("p",null,"See also: ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://tezos.gitlab.io/user/glossary.html#implicit-account"}),"http://tezos.gitlab.io/user/glossary.html#implicit-account")),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),"function main (const kh: key_hash) : contract (unit) is\n  Tezos.implicit_account (kh)\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),"let main (kh : key_hash) : unit contract = Tezos.implicit_account kh\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),"let main = (kh : key_hash): contract (unit) =>\n  Tezos.implicit_account (kh);\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),"let main = (kh: key_hash): contract<unit> =>\n  Tezos.implicit_account(kh);\n"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"const source : address"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val source : address"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let source: address"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let source: address"),Object(o.b)("p",null,"Get the ",Object(o.b)("em",{parentName:"p"},"originator")," (address) of the current transaction. That is, if\na chain of transactions led to the current execution get the address\nthat began the chain. Not to be confused with ",Object(o.b)("inlineCode",{parentName:"p"},"Tezos.sender"),", which\ngives the address of the contract or user which directly caused the\ncurrent transaction."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"\u26a0\ufe0f There are a few caveats you should keep in mind before using\n",Object(o.b)("inlineCode",{parentName:"p"},"Tezos.source")," over ",Object(o.b)("inlineCode",{parentName:"p"},"Tezos.sender"),":"),Object(o.b)("ol",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ol"},Object(o.b)("inlineCode",{parentName:"li"},"Tezos.source")," will never be a contract, so if you want to allow\ncontracts (multisigs etc) to operate your contract, you need to\nuse ",Object(o.b)("inlineCode",{parentName:"li"},"Tezos.sender")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://vessenes.com/tx-origin-and-ethereum-oh-my/"}),"https://vessenes.com/tx-origin-and-ethereum-oh-my/")," -- in general\nit is somewhat unsafe to assume that ",Object(o.b)("inlineCode",{parentName:"li"},"Tezos.source")," understands\neverything that is going to happen in a transaction. If\n",Object(o.b)("inlineCode",{parentName:"li"},"Tezos.source")," transfers to a malicious (or sufficiently\nattackable) contract, that contract might potentially transfer to\nyours, without ",Object(o.b)("inlineCode",{parentName:"li"},"Tezos.source"),"'s consent. So if you are using\n",Object(o.b)("inlineCode",{parentName:"li"},"Tezos.source")," for authentication, you risk being confused. A\ngood historical example of this is bakers paying out delegation\nrewards. Naive bakers did (and probably still do) just use\ntezos-client to transfer to whatever KT1 delegates they had, even\nif those KT1 were malicious scripts."))),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),"function main (const p: unit) : address is Tezos.source\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),"let main (p : unit) : address = Tezos.source\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),"let main = (p : unit) : address => Tezos.source;\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),"let main = (p : unit) : address => Tezos.source;\n"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function failwith : 'a -> unit"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val failwith : 'a -> unit"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let failwith: 'a -> unit"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let failwith: (message: 'a) => unit"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/reference/toplevel#failwith"}),"See ",Object(o.b)("inlineCode",{parentName:"a"},"failwith"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"const chain_id : chain_id"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val chain_id : chain_id"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let chain_id: chain_id"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let chain_id: chain_id"),Object(o.b)("p",null,"Get the identifier of the chain to distinguish between main and test chains."),Object(o.b)("p",null,"This is mainly intended to avoid replay attacks between the chains, and can currently\nonly be used together with ",Object(o.b)("inlineCode",{parentName:"p"},"Bytes.pack")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Bytes.unpack"),"."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),'type storage is bytes\n\nfunction main (const ignore : unit; const storage: storage) :\n  (list(operation) * storage) is block {\n  const packed : bytes = Bytes.pack (Tezos.chain_id);\n  if (storage =/= packed) then {\n   failwith("wrong chain")\n  } else\n    skip;\n} with ((nil: list(operation)), packed)\n'))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),'type storage = bytes\n\nlet main ((ignore, storage): (unit * storage)) =\n  let packed = Bytes.pack Tezos.chain_id in\n  if (storage <> packed) then\n    (failwith "wrong chain" : (operation list * storage))\n  else\n    (([]: operation list), (packed: storage))\n'))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),'type storage = bytes;\n\nlet main = ((ignore, storage): (unit, storage)) => {\n  let packed = Bytes.pack(Tezos.chain_id);\n  if (storage != packed) {\n    (failwith("wrong chain"): (list(operation), storage));\n  } else {\n    ([]: list(operation), packed);\n  }\n};\n'))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),'type storage = bytes;\n\nlet main = ([ignore, storage]: [unit, storage]):[list<operation>, storage] => {\n  let packed = Bytes.pack(Tezos.chain_id);\n  if (storage != packed) {\n    failwith("wrong chain") as [list<operation>, storage];\n  } else {\n    return [(list([]) as list<operation>), packed];\n  };\n};\n'))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function transaction : 'parameter -> mutez -> contract('parameter) -> operation"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val transaction : 'parameter -> mutez -> 'parameter contract -> operation"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let transaction: ('parameter, mutez , contract('parameter)) => operation"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let transaction: (action: 'parameter, amount: mutez, contract: contract<'parameter>) => operation"),Object(o.b)("p",null,"Transfer ",Object(o.b)("inlineCode",{parentName:"p"},"tez")," to an account, or run code of another smart contract."),Object(o.b)("p",null,"To indicate an account, use ",Object(o.b)("inlineCode",{parentName:"p"},"unit")," as ",Object(o.b)("inlineCode",{parentName:"p"},"parameter"),"."),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function set_delegate : option(key_hash) -> operation"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val set_delegate : key_hash option -> operation"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let set_delegate: option(key_hash) => operation"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let set_delegate: (delegate: option<key_hash>) => operation"),Object(o.b)("p",null,"Modify the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://tezos.gitlab.io/user/glossary.html?highlight=delegate#delegate"}),"delegate")," of the current contract."),Object(o.b)("p",null,"The operation fails when:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"the delegate is the same as current delegate"),Object(o.b)("li",{parentName:"ul"},"the keyhash is not of a registered delegate")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"None")," to withdraw the current delegate."),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function get_contract_opt : address -> option(contract('parameter))"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_contract_opt : address -> 'parameter contract option"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let get_contract_opt : address => option(contract('parameter))"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_contract_opt : (a: address) => option<contract<'parameter>>"),Object(o.b)("p",null,"Get a contract from an address."),Object(o.b)("p",null,"When no contract is found or the contract doesn't match the type,\n",Object(o.b)("inlineCode",{parentName:"p"},"None")," is returned."),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function get_entrypoint_opt : string -> address -> option(contract('parameter))"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_entrypoint_opt : string -> address -> 'parameter contract option"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let get_entrypoint_opt: (string, address) => option(contract('parameter))"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_entrypoint_opt: (entrypoint: string, a: address) => option<contract<'parameter>>"),Object(o.b)("p",null,"Get a contract from an address and entrypoint."),Object(o.b)("p",null,"Entrypoints are written in the form of: ",Object(o.b)("inlineCode",{parentName:"p"},"%entrypoint"),"."),Object(o.b)("p",null,"When no contract is found or the contract doesn't match the type,\n",Object(o.b)("inlineCode",{parentName:"p"},"None")," is returned."),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"const level : nat"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val level : nat"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let level : nat"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let level : nat"),Object(o.b)("p",null,"Get the current block level."),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function pairing_check : list(bls12_381_g1 * bls12_381_g2) -> bool"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val pairing_check : (bls12_381_g1 * bls12_381_g2) list -> bool"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let pairing_check: list(bls12_381_g1 , bls12_381_g2) => bool"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let pairing_check: list<[bls12_381_g1, bls12_381_g2]>) => bool"),Object(o.b)("p",null,"Verify that the product of pairings of the given list of points is equal to 1 in Fq12. Returns true if the list is empty.\nCan be used to verify if two pairings P1 and P2 are equal by verifying ",Object(o.b)("inlineCode",{parentName:"p"},"P1 * P2^(-1) = 1"),".\n(extracted from Tezos documentation)"),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function never : never -> 'a"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val never : never -> 'a"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let never: never => 'a"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let never: (never: never) => 'a"),Object(o.b)("p",null,"Eliminate a value of the type ",Object(o.b)("inlineCode",{parentName:"p"},"never")," using the instruction ",Object(o.b)("inlineCode",{parentName:"p"},"NEVER"),"\nfrom Michelson."),Object(o.b)("h2",null,"Sapling"),Object(o.b)("p",null,"Delphi protocol introduced the following sapling types (state and transaction) with N being an int singleton"),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sap_t",group:"sap_t"}),"type st is sapling_state (8)\ntype tr is sapling_transaction (8)\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=sap_t",group:"sap_t"}),"type st = 8 sapling_state\ntype tr = 8 sapling_transaction\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=sap_t",group:"sap_t"}),"type st = sapling_state(8);\ntype tr = sapling_transaction(8);\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=sap_t",group:"sap_t"}),"type st = sapling_state<8>;\ntype tr = sapling_transaction<8>;\n"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"const sapling_empty_state : sapling_state (N)"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val sapling_empty_state : N sapling_state"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let sapling_empty_state: sapling_state(N)"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let sapling_empty_state: sapling_state<N>"),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sap_t",group:"sap_t"}),"const x : st = Tezos.sapling_empty_state ;\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=sap_t",group:"sap_t"}),"let x : st = Tezos.sapling_empty_state\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=sap_t",group:"sap_t"}),"let x : st = Tezos.sapling_empty_state ;\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=sap_t",group:"sap_t"}),"let x : st = Tezos.sapling_empty_state ;\n"))),Object(o.b)("p",null,"Sapling empty state"),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function sapling_verify_update : sapling_transaction (N) -> sapling_state (N) -> option (int * sapling_state (N))"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val sapling_verify_update : N sapling_transaction -> N sapling_state -> (int * N sapling_state) option"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let sapling_verify_update: sapling_transaction(N) => sapling_state(N) => option(int, sapling_state(N))"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let sapling_verify_update: sapling_transaction<N> => sapling_state<N> => option<int, sapling_state<N>>"),Object(o.b)("p",null,"Verify sapling update"),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sap_t",group:"sap_t"}),'function f (const tr : tr) : (int * st) is\n  case (Tezos.sapling_verify_update (tr, x)) of\n    | Some (x) -> x\n    | None -> (failwith ("failed") : (int * st))\n  end\n'))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=sap_t",group:"sap_t"}),'let f (tr : tr) : int * st =\n  match Tezos.sapling_verify_update tr x with\n  | Some x -> x\n  | None -> (failwith "failed" : int * st)\n'))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=sap_t",group:"sap_t"}),'let f = (tr : tr) : (int , st) =>\n  switch (Tezos.sapling_verify_update (tr, x)) {\n    | Some x => x\n    | None => (failwith ("failed") : (int , st))\n  }\n'))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=sap_t",group:"sap_t"}),'let f = (tr : tr) : [int , st] =>\n  match (Tezos.sapling_verify_update(tr, x), {\n    Some: (x: [int, st]) => x,\n    None: () => (failwith ("failed") as [int , st])\n  });\n'))),Object(o.b)("h2",null,"Tickets"),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function create_ticket : 'value -> nat -> ticket ('value)"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val create_ticket : 'value -> nat -> 'value ticket"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let create_ticket : 'value => nat => ticket('value)"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let create_ticket: 'value => nat => ticket<'value>"),Object(o.b)("p",null,"To create a ticket, the value and the amount of tickets to be created needs to be provided.\nThe ticket will also contain the contract address it originated from (which corresponds to ",Object(o.b)("inlineCode",{parentName:"p"},"Tezos.self"),")."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=manip_ticket",group:"manip_ticket"}),'const my_ticket1 : ticket (int) = Tezos.create_ticket (1, 10n)\nconst my_ticket2 : ticket (string) = Tezos.create_ticket ("one", 10n)\n'))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=manip_ticket",group:"manip_ticket"}),'let my_ticket1 : int ticket = Tezos.create_ticket 1 10n\nlet my_ticket2 : string ticket = Tezos.create_ticket "one" 10n\n'))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=manip_ticket",group:"manip_ticket"}),'let my_ticket1 : ticket(int) = Tezos.create_ticket(1, 10n);\nlet my_ticket2 : ticket(string) = Tezos.create_ticket("one", 10n);\n'))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=manip_ticket",group:"manip_ticket"}),'let my_ticket1 : ticket<int> = Tezos.create_ticket(1, 10 as nat);\nlet my_ticket2 : ticket<string> = Tezos.create_ticket("one", 10 as nat);\n'))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function read_ticket : ticket ('value) -> (address * ('value * nat)) * ticket ('value)"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val read_ticket : 'value ticket -> (address * ('value * nat)) * 'value ticket"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let read_ticket : ticket('value) => ((address, ('value , nat)) , ticket('value))"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let read_ticket: ticket<'value> => <<address, <'value , nat>> , ticket<'value>>"),Object(o.b)("p",null,"Reading a ticket will return a tuple with the ticket address, the value and the same ticket for later use.\nA ticket is only consumed when it is dropped (e.g. ",Object(o.b)("inlineCode",{parentName:"p"},"DROP"),"-ed from the Michelson stack) so if the returned ticket isn't stored in some form by your contract, it will be fully consumed."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("p",null,"To read the content of a ticket, you need to use pattern matching"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=manip_ticket",group:"manip_ticket"}),"const v : int =\n  case (Tezos.read_ticket (my_ticket1)) of\n  | (content,ticket) -> (\n    case content of\n    | (addr,x) -> (\n      case x of\n      | (payload,amt) -> (\n        payload\n      ) end\n    ) end\n  ) end\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("p",null,"To read the content of a ticket, you can either use tuple destructuring or pattern matching"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=manip_ticket",group:"manip_ticket"}),"let v1 : int =\n  match (Tezos.read_ticket my_ticket1) with\n  | (content,ticket) -> (\n    match content with\n    | (addr,x) -> (\n      match x with\n      | (payload,amt) -> payload\n    )\n  )\nlet v2 : string =\n  let ((addr,(v,amt)),ticket) = Tezos.read_ticket my_ticket2 in\n  v\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("p",null,"To read the content of a ticket, you need to use tuple destructuring"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=manip_ticket",group:"manip_ticket"}),"let v2 : string =\n  let ((addr,(v,amt)),ticket) = Tezos.read_ticket (my_ticket2) ;\n  v ;\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("p",null,"To read the content of a ticket, you need to use tuple destructuring"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=manip_ticket",group:"manip_ticket"}),"let v2 = (_: unit): string => {\n  let [[addr, [v, amt]], ticket] = Tezos.read_ticket(my_ticket2);\n  return v;\n}\n"))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function split_ticket : ticket ('value) -> nat * nat -> option (ticket('value) * ticket ('value))"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val split_ticket : 'value ticket -> nat * nat -> ('value ticket * 'value ticket) option"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let split_ticket : ticket('value) => (nat , nat) => option ((ticket('value), ticket('value)))"),Object(o.b)(s.a,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let split_ticket: ticket<'value> => <nat , nat> => option <<ticket<'value>, ticket<'value>>>"),Object(o.b)("p",null,"To partially use/consume a ticket, you have to split it.\nProvided a ticket and two amounts, two new tickets will be returned to you if, and only if, the sum equals to the amount of the original ticket."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=manip_ticket",group:"manip_ticket"}),'const x =\n  case Tezos.split_ticket (my_ticket1, (6n, 4n)) of\n  | None -> (failwith ("amt_a + amt_v != amt") : (ticket(int) * ticket(int)))\n  | Some (split_tickets) -> split_tickets\n  end\n'))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=manip_ticket",group:"manip_ticket"}),'let (ta,tb) =\n  match Tezos.split_ticket my_ticket1 (6n, 4n) with\n  | None -> (failwith "amt_a + amt_v != amt" : (int ticket * int ticket))\n  | Some split_tickets -> split_tickets\n'))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=manip_ticket",group:"manip_ticket"}),'let (ta,tb) =\n  switch (Tezos.split_ticket(my_ticket1, (6n, 4n))) {\n  | None => (failwith("amt_a + amt_v != amt") : (ticket(int) , ticket(int)))\n  | Some split_tickets => split_tickets\n  } ;\n'))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=manip_ticket",group:"manip_ticket"}),'let [ta, tb] =\n  match(Tezos.split_ticket(my_ticket1, [6 as nat, 4 as nat]), {\n    None: () => (failwith("amt_a + amt_v != amt") as [ticket<int>, ticket<int>]),\n    Some: (split_tickets: [ticket<int>, ticket<int>]) => split_tickets\n  });\n'))),Object(o.b)(s.a,{syntax:"pascaligo",mdxType:"SyntaxTitle"},"function join_ticket : ticket('value) * ticket ('value) -> option (ticket ('value))"),Object(o.b)(s.a,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val join_ticket : 'value ticket * 'value ticket -> ('value ticket) option"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let join_ticket : (ticket('value), ticket('value)) => option (ticket('value))"),Object(o.b)(s.a,{syntax:"reasonligo",mdxType:"SyntaxTitle"},"let join_ticket = <ticket<'value>, ticket<'value>> => option <ticket<'value>>"),Object(o.b)("p",null,"To add two tickets, you have to join them. This works as the inverse\nof ",Object(o.b)("inlineCode",{parentName:"p"},"Tezos.split_ticket"),".  Provided two tickets with the same ticketer\nand content, they are deleted and a new ticket will be returned with\nan amount equal to the sum of the amounts of the input tickets."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=manip_ticket",group:"manip_ticket"}),"const tc =\n  block {\n    const ta = Tezos.create_ticket(1, 10n);\n    const tb = Tezos.create_ticket(1, 5n)\n  } with Tezos.join_tickets((ta, tb))\n"))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=manip_ticket",group:"manip_ticket"}),"let tc : int ticket option =\n  let ta = Tezos.create_ticket 1 10n in\n  let tb = Tezos.create_ticket 1 5n in\n  Tezos.join_tickets (ta, tb)\n"))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=manip_ticket",group:"manip_ticket"}),"let tc =\n  let ta = Tezos.create_ticket(1, 10n);\n  let tb = Tezos.create_ticket(1, 5n);\n  Tezos.join_tickets((ta, tb));\n"))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=manip_ticket",group:"manip_ticket"}),"let ta = Tezos.create_ticket(1, 10 as nat);\nlet tb = Tezos.create_ticket(1, 5 as nat);\nlet tc = Tezos.join_tickets([ta, tb]);\n"))),Object(o.b)("h3",{id:"linearity"},"Linearity"),Object(o.b)("p",null,"If a contract storage type contains a ticket, you must destructure the parameter-storage pair within the body to preserve storage linearity (e.g. avoid ",Object(o.b)("inlineCode",{parentName:"p"},"DUP"),"-ing storage).\nFor the same reasons, if tickets are stored in a ",Object(o.b)("inlineCode",{parentName:"p"},"map"),"/",Object(o.b)("inlineCode",{parentName:"p"},"big_map")," you must use the new operator ",Object(o.b)("inlineCode",{parentName:"p"},"get_and_update")," to update your bindings."),Object(o.b)(c.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=contract_ticket",group:"contract_ticket"}),'type storage is big_map (string, ticket(int))\ntype parameter is int\ntype return is list (operation) * storage\n\nfunction main (const i : parameter ; const store : storage) : return is\n  block {\n    const my_ticket1 : ticket(int) = Tezos.create_ticket (i, 10n) ;\n    const res = Big_map.get_and_update("hello", (Some (my_ticket1)), store) ;\n    var res : return := ((nil : list (operation)), store) ;\n    case res of\n    | (t,x) -> res := ((nil : list (operation)), x)\n    end\n  } with res\n'))),Object(o.b)(c.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=contract_ticket",group:"contract_ticket"}),'type storage = (string, int ticket) big_map\ntype parameter = int\ntype return = operation list * storage\n\nlet main (x : parameter * storage) : return =\n  let (i,store) = x in\n  let my_ticket1 : int ticket = Tezos.create_ticket i 10n in\n  let (_,x) = Big_map.get_and_update "hello" (Some my_ticket1) store in\n  (([] : operation list), x)\n'))),Object(o.b)(c.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=contract_ticket",group:"contract_ticket"}),'type storage = big_map (string, ticket(int)) ;\n\ntype parameter = int ;\n\ntype return = (list (operation), storage);\n\nlet main = (x : (parameter , storage)) : return => {\n  let (i,store) = x ;\n  let my_ticket1 : ticket(int) = Tezos.create_ticket (i, 10n) ;\n  let (_,x) = Big_map.get_and_update ("hello", Some(my_ticket1), store) ;\n  (([] : list(operation)), x)\n};\n'))),Object(o.b)(c.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=contract_ticket",group:"contract_ticket"}),'type storage = big_map<string, ticket<int>> ;\n\ntype parameter = int ;\n\ntype return_ = [list<operation>, storage];\n\nlet main = (x: [parameter, storage]): return_ => {\n  let [i, store] = x ;\n  let my_ticket1: ticket<int> = Tezos.create_ticket (i, 10 as nat);\n  let [_, x] = Big_map.get_and_update ("hello", Some(my_ticket1), store);\n  return [list([]) as list<operation>, x]\n};\n'))))}m.isMDXComponent=!0},457:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return g}));var n=a(0),i=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function c(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?c(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=i.a.createContext({}),p=function(e){var t=i.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},b=function(e){var t=p(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},y=i.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,l=r(e,["components","mdxType","originalType","parentName"]),b=p(a),y=n,g=b["".concat(c,".").concat(y)]||b[y]||m[y]||o;return a?i.a.createElement(g,s(s({ref:t},l),{},{components:a})):i.a.createElement(g,s({ref:t},l))}));function g(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,c=new Array(o);c[0]=y;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s.mdxType="string"==typeof e?e:n,c[1]=s;for(var l=2;l<o;l++)c[l]=a[l];return i.a.createElement.apply(null,c)}return i.a.createElement.apply(null,a)}y.displayName="MDXCreateElement"},458:function(e,t,a){"use strict";var n=a(0),i=a.n(n).a.createContext("pascaligo");t.a=i},459:function(e,t,a){"use strict";var n=a(0),i=a.n(n),o=a(458);a.d(t,"a",(function(){return o.a})),t.b=function(e){return i.a.createElement(o.a.Consumer,null,(function(t){return t===e.syntax?e.children:i.a.createElement(i.a.Fragment,null)}))}},460:function(e,t,a){"use strict";a.r(t),a.d(t,"Prism",(function(){return n.a})),a.d(t,"defaultProps",(function(){return c}));var n=a(22),i={plain:{backgroundColor:"#2a2734",color:"#9a86fd"},styles:[{types:["comment","prolog","doctype","cdata","punctuation"],style:{color:"#6c6783"}},{types:["namespace"],style:{opacity:.7}},{types:["tag","operator","number"],style:{color:"#e09142"}},{types:["property","function"],style:{color:"#9a86fd"}},{types:["tag-id","selector","atrule-id"],style:{color:"#eeebff"}},{types:["attr-name"],style:{color:"#c4b9fe"}},{types:["boolean","string","entity","url","attr-value","keyword","control","directive","unit","statement","regex","at-rule","placeholder","variable"],style:{color:"#ffcc99"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"#c4b9fe"}}]},o=a(0),c={Prism:n.a,theme:i};function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var l=/\r\n|\r|\n/,p=function(e){0===e.length?e.push({types:["plain"],content:"",empty:!0}):1===e.length&&""===e[0].content&&(e[0].empty=!0)},b=function(e,t){var a=e.length;return a>0&&e[a-1]===t?e:e.concat(t)},m=function(e,t){var a=e.plain,n=Object.create(null),i=e.styles.reduce((function(e,a){var n=a.languages,i=a.style;return n&&!n.includes(t)||a.types.forEach((function(t){var a=r({},e[t],i);e[t]=a})),e}),n);return i.root=a,i.plain=r({},a,{backgroundColor:null}),i};function y(e,t){var a={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&-1===t.indexOf(n)&&(a[n]=e[n]);return a}var g=function(e){function t(){for(var t=this,a=[],n=arguments.length;n--;)a[n]=arguments[n];e.apply(this,a),s(this,"getThemeDict",(function(e){if(void 0!==t.themeDict&&e.theme===t.prevTheme&&e.language===t.prevLanguage)return t.themeDict;t.prevTheme=e.theme,t.prevLanguage=e.language;var a=e.theme?m(e.theme,e.language):void 0;return t.themeDict=a})),s(this,"getLineProps",(function(e){var a=e.key,n=e.className,i=e.style,o=r({},y(e,["key","className","style","line"]),{className:"token-line",style:void 0,key:void 0}),c=t.getThemeDict(t.props);return void 0!==c&&(o.style=c.plain),void 0!==i&&(o.style=void 0!==o.style?r({},o.style,i):i),void 0!==a&&(o.key=a),n&&(o.className+=" "+n),o})),s(this,"getStyleForToken",(function(e){var a=e.types,n=e.empty,i=a.length,o=t.getThemeDict(t.props);if(void 0!==o){if(1===i&&"plain"===a[0])return n?{display:"inline-block"}:void 0;if(1===i&&!n)return o[a[0]];var c=n?{display:"inline-block"}:{},s=a.map((function(e){return o[e]}));return Object.assign.apply(Object,[c].concat(s))}})),s(this,"getTokenProps",(function(e){var a=e.key,n=e.className,i=e.style,o=e.token,c=r({},y(e,["key","className","style","token"]),{className:"token "+o.types.join(" "),children:o.content,style:t.getStyleForToken(o),key:void 0});return void 0!==i&&(c.style=void 0!==c.style?r({},c.style,i):i),void 0!==a&&(c.key=a),n&&(c.className+=" "+n),c}))}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.render=function(){var e=this.props,t=e.Prism,a=e.language,n=e.code,i=e.children,o=this.getThemeDict(this.props),c=t.languages[a];return i({tokens:function(e){for(var t=[[]],a=[e],n=[0],i=[e.length],o=0,c=0,s=[],r=[s];c>-1;){for(;(o=n[c]++)<i[c];){var m=void 0,y=t[c],g=a[c][o];if("string"==typeof g?(y=c>0?y:["plain"],m=g):(y=b(y,g.type),g.alias&&(y=b(y,g.alias)),m=g.content),"string"==typeof m){var u=m.split(l),d=u.length;s.push({types:y,content:u[0]});for(var j=1;j<d;j++)p(s),r.push(s=[]),s.push({types:y,content:u[j]})}else c++,t.push(y),a.push(m),n.push(0),i.push(m.length)}c--,t.pop(),a.pop(),n.pop(),i.pop()}return p(s),r}(void 0!==c?t.tokenize(n,c,a):[n]),className:"prism-code language-"+a,style:void 0!==o?o.root:{},getLineProps:this.getLineProps,getTokenProps:this.getTokenProps})},t}(o.Component);t.default=g},461:function(e,t,a){"use strict";var n=a(0),i=a(463);t.a=function(){var e=Object(n.useContext)(i.a);if(null==e)throw new Error("`useThemeContext` is used outside of `Layout` Component. See https://v2.docusaurus.io/docs/theme-classic#usethemecontext.");return e}},462:function(e,t,a){"use strict";t.a={plain:{color:"#bfc7d5",backgroundColor:"#292d3e"},styles:[{types:["comment"],style:{color:"rgb(105, 112, 152)",fontStyle:"italic"}},{types:["string","inserted"],style:{color:"rgb(195, 232, 141)"}},{types:["number"],style:{color:"rgb(247, 140, 108)"}},{types:["builtin","char","constant","function"],style:{color:"rgb(130, 170, 255)"}},{types:["punctuation","selector"],style:{color:"rgb(199, 146, 234)"}},{types:["variable"],style:{color:"rgb(191, 199, 213)"}},{types:["class-name","attr-name"],style:{color:"rgb(255, 203, 107)"}},{types:["tag","deleted"],style:{color:"rgb(255, 85, 114)"}},{types:["operator"],style:{color:"rgb(137, 221, 255)"}},{types:["boolean"],style:{color:"rgb(255, 88, 116)"}},{types:["keyword"],style:{fontStyle:"italic"}},{types:["doctype"],style:{color:"rgb(199, 146, 234)",fontStyle:"italic"}},{types:["namespace"],style:{color:"rgb(178, 204, 214)"}},{types:["url"],style:{color:"rgb(221, 221, 221)"}}]}},463:function(e,t,a){"use strict";var n=a(0),i=a.n(n).a.createContext(void 0);t.a=i},464:function(e,t,a){"use strict";var n=a(0),i=a.n(n),o=a(460),c=a(23),s=a(461),r=a(459),l=a(462);function p(){return(p=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var b=a(460).Prism;b.languages=Object.assign({},b.languages,{pascaligo:{comment:[/\(\*[\s\S]+?\*\)/,/\/\/.*/],string:{pattern:/(?:'(?:''|[^'\r\n])*'|#[&$%]?[a-f\d]+)+|\^[a-z]/i,greedy:!0},keyword:[{pattern:/(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,lookbehind:!0},{pattern:/(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,lookbehind:!0},{pattern:/(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,lookbehind:!0},{pattern:/(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,lookbehind:!0}],number:[/(?:[&%]\d+|\$[a-f\d]+)/i,/\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i],operator:[/\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/i,{pattern:/(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,lookbehind:!0}],punctuation:/\(\.|\.\)|[()\[\]:;,.]/},reasonligo:Object.assign({},b.languages.reason,{comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]}),cameligo:Object.assign({},b.languages.ocaml,{comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]}),jsligo:b.languages.typescript}),t.a=function(e){var t=Object(c.default)().siteConfig.themeConfig.prism,a=void 0===t?{}:t,b=Object(s.a)().isDarkTheme,m=a.theme||l.a,y=a.darkTheme||m,g=b?y:m,u=Object(n.useState)(!1),d=u[0],j=u[1];return Object(n.useEffect)((function(){j(!0)}),[]),i.a.createElement(r.a.Consumer,null,(function(t){return t===e.syntax?i.a.createElement(o.default,p({},o.defaultProps,{key:d,language:e.syntax,code:e.children,theme:g}),(function(e){var t=e.className,a=(e.style,e.tokens),n=e.getLineProps,o=e.getTokenProps;return i.a.createElement("pre",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},a.map((function(e,t){return i.a.createElement("div",n({line:e,key:t}),e.map((function(e,t){return i.a.createElement("span",o({token:e,key:t}))})))})))})):i.a.createElement("div",null)}))}}}]);