(window.webpackJsonp=window.webpackJsonp||[]).push([[236],{310:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return o})),t.d(n,"toc",(function(){return r})),t.d(n,"default",(function(){return b}));var a=t(3),i=t(7),c=(t(0),t(457)),l=t(459),s={id:"functions",title:"Functions"},o={unversionedId:"language-basics/functions",id:"version-0.25.0/language-basics/functions",isDocsHomePage:!1,title:"Functions",description:"LIGO functions are the basic building block of contracts. For example,",source:"@site/versioned_docs/version-0.25.0/language-basics/functions.md",slug:"/language-basics/functions",permalink:"/docs/language-basics/functions",version:"0.25.0",sidebar:"version-0.25.0/docs",previous:{title:"Strings",permalink:"/docs/language-basics/strings"},next:{title:"Booleans and Conditionals",permalink:"/docs/language-basics/boolean-if-else"}},r=[{value:"Declaring Functions",id:"declaring-functions",children:[{value:"Blocks",id:"blocks",children:[]},{value:"Blockless functions",id:"blockless-functions",children:[]}]},{value:"Anonymous functions (a.k.a. lambdas)",id:"anonymous-functions-aka-lambdas",children:[]},{value:"Nested functions (also known as closures)",id:"nested-functions-also-known-as-closures",children:[]},{value:"Recursive function",id:"recursive-function",children:[]},{value:"Recursive function",id:"recursive-function-1",children:[]},{value:"Recursive function",id:"recursive-function-2",children:[]}],u={toc:r};function b(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(c.b)("wrapper",Object(a.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(c.b)("p",null,"LIGO functions are the basic building block of contracts. For example,\nentrypoints are functions and each smart contract needs a main\nfunction that dispatches control to the entrypoints (it is not already\nthe default entrypoint)."),Object(c.b)("p",null,"The semantics of function calls in LIGO is that of a ",Object(c.b)("em",{parentName:"p"},"copy of the\narguments but also of the environment"),". In the case of PascaLIGO, this\nmeans that any mutation (assignment) on variables outside the scope of\nthe function will be lost when the function returns, just as the\nmutations inside the functions will be."),Object(c.b)("h2",{id:"declaring-functions"},"Declaring Functions"),Object(c.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(c.b)("p",null,"There are two ways in PascaLIGO to define functions: with or without a\n",Object(c.b)("em",{parentName:"p"},"block"),"."),Object(c.b)("h3",{id:"blocks"},"Blocks"),Object(c.b)("p",null,"In PascaLIGO, ",Object(c.b)("em",{parentName:"p"},"blocks")," enable the sequential composition of\ninstructions into an isolated scope. Each block needs to include at\nleast one instruction."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"skip",skip:!0}),"block { a := a + 1 }\n")),Object(c.b)("p",null,"If we need a placeholder, we use the instruction ",Object(c.b)("inlineCode",{parentName:"p"},"skip")," which leaves\nthe state unchanged.  The rationale for ",Object(c.b)("inlineCode",{parentName:"p"},"skip")," instead of a truly\nempty block is that it prevents you from writing an empty block by\nmistake."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"skip",skip:!0}),"block { skip }\n")),Object(c.b)("p",null,"Blocks are more versatile than simply containing instructions: they\ncan also include ",Object(c.b)("em",{parentName:"p"},"declarations")," of values, like so:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"skip",skip:!0}),"block { const a : int = 1 }\n")),Object(c.b)("p",null,"Functions in PascaLIGO are defined using the ",Object(c.b)("inlineCode",{parentName:"p"},"function")," keyword\nfollowed by their ",Object(c.b)("inlineCode",{parentName:"p"},"name"),", ",Object(c.b)("inlineCode",{parentName:"p"},"parameters")," and ",Object(c.b)("inlineCode",{parentName:"p"},"return")," type definitions."),Object(c.b)("p",null,"Here is how you define a basic function that computes the sum of two\nintegers:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=a",group:"a"}),"function add (const a : int; const b : int) : int is\n  block {\n    const sum : int = a + b\n  } with sum\n")),Object(c.b)("p",null,"The function body consists of two parts:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},Object(c.b)("inlineCode",{parentName:"li"},"block { <instructions and declarations> }")," is the logic of the function;"),Object(c.b)("li",{parentName:"ul"},Object(c.b)("inlineCode",{parentName:"li"},"with <value>")," is the value returned by the function.")),Object(c.b)("p",null,"By default, LIGO will warn about unused parameters inside\nfunctions. In case we do not use a parameter, we can use the wildcard\n",Object(c.b)("inlineCode",{parentName:"p"},"_")," to prevent warnings. Either use ",Object(c.b)("inlineCode",{parentName:"p"},"_")," instead of the parameter\nidentifier:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo"}),"function k (const x : int; const _ : int) is x\n")),Object(c.b)("p",null,"or use a parameter identifier starting with wildcard:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo"}),"function k (const x : int; const _y : int) is x\n")),Object(c.b)("h3",{id:"blockless-functions"},"Blockless functions"),Object(c.b)("p",null,"Functions that can contain all of their logic into a single\n",Object(c.b)("em",{parentName:"p"},"expression")," can be defined without the need of a block:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo"}),"function identity (const n : int) : int is block { skip } with n  // Bad! Empty block not needed!\n\nfunction identity (const n : int) : int is n  // Blockless\n")),Object(c.b)("p",null,"The value of the expression is implicitly returned by the\nfunction. Another example is as follows:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=b",group:"b"}),"function add (const a: int; const b : int) : int is a + b\n")),Object(c.b)("p",null,"You can call the function ",Object(c.b)("inlineCode",{parentName:"p"},"add")," defined above using the LIGO compiler\nlike this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call gitlab-pages/docs/language-basics/src/functions/blockless.ligo add '(1,2)'\n# Outputs: 3\n"))),Object(c.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(c.b)("p",null,"Functions in CameLIGO are defined using the ",Object(c.b)("inlineCode",{parentName:"p"},"let")," keyword, like other\nvalues. The difference is that a succession of parameters is provided\nafter the value name, followed by the return type. This follows OCaml\nsyntax. For example:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=c",group:"c"}),"let add (a : int) (b : int) : int = a + b\n")),Object(c.b)("p",null,"You can call the function ",Object(c.b)("inlineCode",{parentName:"p"},"add")," defined above using the LIGO compiler\nlike this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call gitlab-pages/docs/language-basics/src/functions/blockless.mligo add '(1,2)'\n# Outputs: 3\n")),Object(c.b)("p",null,"CameLIGO is a little different from other syntaxes when it comes to\nfunction parameters. In OCaml, functions can only take one\nparameter. To get functions with multiple arguments like we are used\nto in imperative programming languages, a technique called\n",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Currying"}),"currying")," is used.  Currying\nessentially translates a function with multiple arguments into a\nseries of single argument functions, each returning a new function\naccepting the next argument until every parameter is filled. This is\nuseful because it means that CameLIGO supports\n",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Partial_application"}),"partial application"),"."),Object(c.b)("p",null,"Currying is however ",Object(c.b)("em",{parentName:"p"},"not")," the preferred way to pass function arguments\nin CameLIGO.  While this approach is faithful to the original OCaml,\nit is costlier in Michelson than naive function execution accepting\nmultiple arguments. Instead, for most functions with more than one\nparameter, we should gather the arguments in a\n",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/language-basics/sets-lists-tuples"}),"tuple")," and pass the tuple in as\na single parameter."),Object(c.b)("p",null,"Here is how you define a basic function that accepts two integers and\nreturns an integer as well:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=b",group:"b"}),"let add (a, b : int * int) : int = a + b             // Uncurried\nlet add_curry (a : int) (b : int) : int = add (a, b) // Curried\nlet increment : int -> int = add_curry 1             // Partial application\n")),Object(c.b)("p",null,"You can run the ",Object(c.b)("inlineCode",{parentName:"p"},"increment")," function defined above using the LIGO\ncompiler like this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call gitlab-pages/docs/language-basics/src/functions/curry.mligo increment 5\n# Outputs: 6\n")),Object(c.b)("p",null,"The function body is a single expression, whose value is returned."),Object(c.b)("p",null,"By default, LIGO will warn about unused arguments inside\nfunctions. In case we do not use an argument, we can use the wildcard\n",Object(c.b)("inlineCode",{parentName:"p"},"_")," to prevent warnings. Either use ",Object(c.b)("inlineCode",{parentName:"p"},"_")," instead of the argument\nidentifier:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo"}),"let k (x : int) (_ : int) = x\n")),Object(c.b)("p",null,"or use an identifier starting with wildcard:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo"}),"let k (x : int) (_y : int) = x\n"))),Object(c.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(c.b)("p",null,"Functions in ReasonLIGO are defined using the ",Object(c.b)("inlineCode",{parentName:"p"},"let")," keyword, like\nother values. The difference is that a tuple of parameters is provided\nafter the value name, with its type, then followed by the return type."),Object(c.b)("p",null,"Here is how you define a basic function that sums two integers:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=b",group:"b"}),"let add = ((a, b): (int, int)) : int => a + b;\n")),Object(c.b)("p",null,"You can call the function ",Object(c.b)("inlineCode",{parentName:"p"},"add")," defined above using the LIGO compiler\nlike this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call gitlab-pages/docs/language-basics/src/functions/blockless.religo add '(1,2)'\n# Outputs: 3\n")),Object(c.b)("p",null,"As in CameLIGO and with blockless functions in PascaLIGO, the function\nbody is a single expression, whose value is returned."),Object(c.b)("p",null,"If the body contains more than a single expression, you use block\nbetween braces:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=b",group:"b"}),"let myFun = ((x, y) : (int, int)) : int => {\n  let doubleX = x + x;\n  let doubleY = y + y;\n  doubleX + doubleY\n};\n")),Object(c.b)("p",null,"By default, LIGO will warn about unused arguments inside\nfunctions. In case we do not use an argument, we can use the wildcard\n",Object(c.b)("inlineCode",{parentName:"p"},"_")," to prevent warnings. Either use ",Object(c.b)("inlineCode",{parentName:"p"},"_")," instead of the argument\nidentifier:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo"}),"let k = ((x, _) : (int, int)) => x;\n")),Object(c.b)("p",null,"or use an identifier starting with wildcard:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo"}),"let k = ((x, _y) : (int, int)) => x;\n"))),Object(c.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(c.b)("p",null,"Functions in JsLIGO are defined using the ",Object(c.b)("inlineCode",{parentName:"p"},"let")," or ",Object(c.b)("inlineCode",{parentName:"p"},"const")," keyword, like\nother values. The difference is that parameters are provided\nafter the value name, with its type, then followed by the return type."),Object(c.b)("p",null,"Here is how you define a basic function that sums two integers:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=b",group:"b"}),"let add = ([a, b]: [int, int]): int => a + b;\n")),Object(c.b)("p",null,"You can call the function ",Object(c.b)("inlineCode",{parentName:"p"},"add")," defined above using the LIGO compiler\nlike this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call gitlab-pages/docs/language-basics/src/functions/blockless.jsligo add '(1,2)'\n# Outputs: 3\n")),Object(c.b)("p",null,"As in CameLIGO and with blockless functions in PascaLIGO, the function\nbody is a single expression, whose value is returned."),Object(c.b)("p",null,"If the body contains more than a single expression, you use block\nbetween braces:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=b",group:"b"}),"let myFun = ([x, y]: [int, int]): int => {\n  let doubleX = x + x;\n  let doubleY = y + y;\n  return doubleX + doubleY;\n};\n")),Object(c.b)("p",null,"Note that JsLIGO, like JavaScript, requires the ",Object(c.b)("inlineCode",{parentName:"p"},"return")," keyword to indicate\nwhat is being returned. If ",Object(c.b)("inlineCode",{parentName:"p"},"return")," is not used, it will be the same as\n",Object(c.b)("inlineCode",{parentName:"p"},"return unit"),"."),Object(c.b)("p",null,"By default, LIGO will warn about unused arguments inside\nfunctions. In case we do not use an argument, we can use the wildcard\n",Object(c.b)("inlineCode",{parentName:"p"},"_")," to prevent warnings. Either use ",Object(c.b)("inlineCode",{parentName:"p"},"_")," instead of the argument\nidentifier:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo"}),"let k = ([x, _] : [int, int]) : int => x;\n")),Object(c.b)("p",null,"or use an identifier starting with wildcard:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo"}),"let k = ([x, _y] : [int, int]) : int => x;\n"))),Object(c.b)("h2",{id:"anonymous-functions-aka-lambdas"},"Anonymous functions (a.k.a. lambdas)"),Object(c.b)("p",null,"It is possible to define functions without assigning them a name. They\nare useful when you want to pass them as arguments, or assign them to\na key in a record or a map."),Object(c.b)("p",null,"Here is how to define an anonymous function:"),Object(c.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=c",group:"c"}),"function increment (const b : int) : int is\n   (function (const a : int) : int is a + 1) (b)\nconst a : int = increment (1); // a = 2\n")),Object(c.b)("p",null,"You can check the value of ",Object(c.b)("inlineCode",{parentName:"p"},"a")," defined above using the LIGO compiler\nlike this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-expr gitlab-pages/docs/language-basics/src/functions/anon.ligo a\n# Outputs: 2\n"))),Object(c.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=c",group:"c"}),"let increment (b : int) : int = (fun (a : int) -> a + 1) b\nlet a : int = increment 1 // a = 2\n")),Object(c.b)("p",null,"You can check the value of ",Object(c.b)("inlineCode",{parentName:"p"},"a")," defined above using the LIGO compiler\nlike this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-expr gitlab-pages/docs/language-basics/src/functions/anon.mligo a\n# Outputs: 2\n"))),Object(c.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=c",group:"c"}),"let increment = (b : int) : int => ((a : int) : int => a + 1) (b);\nlet a : int = increment (1); // a == 2\n")),Object(c.b)("p",null,"You can check the value of ",Object(c.b)("inlineCode",{parentName:"p"},"a")," defined above using the LIGO compiler\nlike this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-expr gitlab-pages/docs/language-basics/src/functions/anon.religo a\n# Outputs: 2\n"))),Object(c.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=c",group:"c"}),"let increment = (b: int): int => ((a: int): int => a + 1) (b);\nlet a: int = increment(1); // a == 2\n")),Object(c.b)("p",null,"You can check the value of ",Object(c.b)("inlineCode",{parentName:"p"},"a")," defined above using the LIGO compiler\nlike this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-expr gitlab-pages/docs/language-basics/src/functions/anon.jsligo a\n# Outputs: 2\n"))),Object(c.b)("p",null,"If the example above seems contrived, here is a more common design\npattern for lambdas: to be used as parameters to functions. Consider\nthe use case of having a list of integers and mapping the increment\nfunction to all its elements."),Object(c.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=c",group:"c"}),"function incr_map (const l : list (int)) : list (int) is\n  List.map (function (const i : int) : int is i + 1, l)\n")),Object(c.b)("p",null,"You can call the function ",Object(c.b)("inlineCode",{parentName:"p"},"incr_map")," defined above using the LIGO\ncompiler like so:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/functions/incr_map.ligo incr_map\n"list [1;2;3]"\n# Outputs: [ 2 ; 3 ; 4 ]\n'))),Object(c.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=c",group:"c"}),"let incr_map (l : int list) : int list =\n  List.map (fun (i : int) -> i + 1) l\n")),Object(c.b)("p",null,"You can call the function ",Object(c.b)("inlineCode",{parentName:"p"},"incr_map")," defined above using the LIGO compiler\nlike so:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/functions/incr_map.mligo incr_map\n"list [1;2;3]"\n# Outputs: [ 2 ; 3 ; 4 ]\n'))),Object(c.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=c",group:"c"}),"let incr_map = (l : list (int)) : list (int) =>\n  List.map ((i : int) => i + 1, l);\n")),Object(c.b)("p",null,"You can call the function ",Object(c.b)("inlineCode",{parentName:"p"},"incr_map")," defined above using the LIGO compiler\nlike so:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/functions/incr_map.religo incr_map\n"list [1;2;3]"\n# Outputs: [ 2 ; 3 ; 4 ]\n'))),Object(c.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=c",group:"c"}),"let incr_map = (l: list<int>): list<int> =>\n  List.map((i: int) => i + 1, l);\n")),Object(c.b)("p",null,"You can call the function ",Object(c.b)("inlineCode",{parentName:"p"},"incr_map")," defined above using the LIGO compiler\nlike so:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/functions/incr_map.jsligo incr_map\n"list [1;2;3]"\n# Outputs: [ 2 ; 3 ; 4 ]\n'))),Object(c.b)("h2",{id:"nested-functions-also-known-as-closures"},"Nested functions (also known as closures)"),Object(c.b)("p",null,"It's possible to place functions inside other functions. These functions\nhave access to variables in the same scope. "),Object(c.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo"}),"function closure_example (const i : int) : int is\n  block {\n    function closure (const j : int) : int is i + j\n  } with closure (i)\n"))),Object(c.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo"}),"let closure_example (i : int) : int =\n  let closure : int -> int = fun (j : int) -> i + j in\n  closure i\n"))),Object(c.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo"}),"let closure_example = (i : int) : int => {\n  let closure = (j: int): int => i + j;\n  closure(i);\n};\n"))),Object(c.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo"}),"let closure_example = (i: int): int => {\n  let closure = (j: int): int => i + j;\n  return closure(i);\n};\n"))),Object(c.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(c.b)("h2",{id:"recursive-function"},"Recursive function"),Object(c.b)("p",null,"LIGO functions are not recursive by default, the user need to indicate that the function is recursive."),Object(c.b)("p",null,"At the moment, recursive function are limited to one (possibly tupled) parameter and recursion is\nlimited to tail recursion (i.e the recursive call should be the last expression of the function)."),Object(c.b)("p",null,"In PascaLIGO recursive functions are defined using the ",Object(c.b)("inlineCode",{parentName:"p"},"recursive")," keyword"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=d",group:"d"}),"recursive function sum (const n : int; const acc: int) : int is\n  if n<1 then acc else sum(n-1,acc+n)\n\nrecursive function fibo (const n: int; const n_1: int; const n_0 :int) : int is\n  if n<2 then n_1 else fibo(n-1,n_1+n_0,n_1)\n"))),Object(c.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(c.b)("h2",{id:"recursive-function-1"},"Recursive function"),Object(c.b)("p",null,"LIGO functions are not recursive by default, the user need to indicate that the function is recursive."),Object(c.b)("p",null,"At the moment, recursive function are limited to one (possibly tupled) parameter and recursion is\nlimited to tail recursion (i.e the recursive call should be the last expression of the function)"),Object(c.b)("p",null,"In CameLIGO recursive functions are defined using the ",Object(c.b)("inlineCode",{parentName:"p"},"rec")," keyword"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=d",group:"d"}),"let rec sum ((n,acc):int * int) : int =\n    if (n < 1) then acc else sum (n-1, acc+n)\n \nlet rec fibo ((n,n_1,n_0):int*int*int) : int = \n    if (n < 2) then n_1 else fibo (n-1, n_1 + n_0, n_1)\n"))),Object(c.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(c.b)("h2",{id:"recursive-function-2"},"Recursive function"),Object(c.b)("p",null,"LIGO functions are not recursive by default, the user need to indicate that the function is recursive."),Object(c.b)("p",null,"At the moment, recursive function are limited to one (possibly tupled) parameter and recursion is\nlimited to tail recursion (i.e the recursive call should be the last expression of the function)"),Object(c.b)("p",null,"In ReasonLIGO recursive functions are defined using the ",Object(c.b)("inlineCode",{parentName:"p"},"rec")," keyword"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=d",group:"d"}),"let rec sum = ((n, acc) : (int,int)): int =>\n    if (n < 1) {acc;} else {sum ((n-1,acc+n));};\n\nlet rec fibo = ((n, n_1, n_0) : (int,int,int)): int =>\n    if (n < 2) {n_1;} else {fibo ((n-1,n_1+n_0,n_1));};\n"))))}b.isMDXComponent=!0},457:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return m}));var a=t(0),i=t.n(a);function c(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){c(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},c=Object.keys(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var r=i.a.createContext({}),u=function(e){var n=i.a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},b=function(e){var n=u(e.components);return i.a.createElement(r.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},d=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,c=e.originalType,l=e.parentName,r=o(e,["components","mdxType","originalType","parentName"]),b=u(t),d=a,m=b["".concat(l,".").concat(d)]||b[d]||p[d]||c;return t?i.a.createElement(m,s(s({ref:n},r),{},{components:t})):i.a.createElement(m,s({ref:n},r))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var c=t.length,l=new Array(c);l[0]=d;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s.mdxType="string"==typeof e?e:a,l[1]=s;for(var r=2;r<c;r++)l[r]=t[r];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},458:function(e,n,t){"use strict";var a=t(0),i=t.n(a).a.createContext("pascaligo");n.a=i},459:function(e,n,t){"use strict";var a=t(0),i=t.n(a),c=t(458);t.d(n,"a",(function(){return c.a})),n.b=function(e){return i.a.createElement(c.a.Consumer,null,(function(n){return n===e.syntax?e.children:i.a.createElement(i.a.Fragment,null)}))}}}]);