(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{234:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"metadata",(function(){return l})),t.d(n,"toc",(function(){return s})),t.d(n,"default",(function(){return b}));var a=t(3),i=t(7),r=(t(0),t(457)),o=t(459),c={id:"unit-option-pattern-matching",title:"Unit, Option, Pattern matching"},l={unversionedId:"language-basics/unit-option-pattern-matching",id:"version-0.25.0/language-basics/unit-option-pattern-matching",isDocsHomePage:!1,title:"Unit, Option, Pattern matching",description:"Optionals are a pervasive programming pattern in OCaml. Since Michelson",source:"@site/versioned_docs/version-0.25.0/language-basics/unit-option-pattern-matching.md",slug:"/language-basics/unit-option-pattern-matching",permalink:"/docs/language-basics/unit-option-pattern-matching",version:"0.25.0",sidebar:"version-0.25.0/docs",previous:{title:"Iteration",permalink:"/docs/language-basics/loops"},next:{title:"Records and Maps",permalink:"/docs/language-basics/maps-records"}},s=[{value:"The unit Type",id:"the-unit-type",children:[]},{value:"Variant types",id:"variant-types",children:[]},{value:"Optional values",id:"optional-values",children:[]},{value:"Pattern matching",id:"pattern-matching",children:[{value:"Match on variants",id:"match-on-variants",children:[]},{value:"Match on records or tuples",id:"match-on-records-or-tuples",children:[]},{value:"Match on lists",id:"match-on-lists",children:[]},{value:"Deep patterns",id:"deep-patterns",children:[]}]}],p={toc:s};function b(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Optionals are a pervasive programming pattern in OCaml. Since Michelson\nand LIGO are both inspired by OCaml, ",Object(r.b)("em",{parentName:"p"},"optional types")," are available in\nLIGO as well. Similarly, OCaml features a ",Object(r.b)("em",{parentName:"p"},"unit")," type, and LIGO\nfeatures it as well. Both the option type and the unit types are\ninstances of a more general kind of types: ",Object(r.b)("em",{parentName:"p"},"variant types")," (sometimes\ncalled ",Object(r.b)("em",{parentName:"p"},"sum types"),")."),Object(r.b)("h2",{id:"the-unit-type"},"The unit Type"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"unit")," type in Michelson or LIGO is a predefined type that\ncontains only one value that carries no information. It is used when\nno relevant information is required or produced. Here is how it used."),Object(r.b)(o.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("p",null,"In PascaLIGO, the unique value of the ",Object(r.b)("inlineCode",{parentName:"p"},"unit")," type is ",Object(r.b)("inlineCode",{parentName:"p"},"Unit"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=a",group:"a"}),"const n : unit = Unit // Note the capital letter\n"))),Object(r.b)(o.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("p",null,"In CameLIGO, the unique value of the ",Object(r.b)("inlineCode",{parentName:"p"},"unit")," type is ",Object(r.b)("inlineCode",{parentName:"p"},"()"),", following\nthe OCaml convention."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=a",group:"a"}),"let n : unit = ()\n")),Object(r.b)("p",null,"Sequences of expressions that return the ",Object(r.b)("inlineCode",{parentName:"p"},"unit")," type can be written\nusing ",Object(r.b)("inlineCode",{parentName:"p"},"begin")," and ",Object(r.b)("inlineCode",{parentName:"p"},"end"),", separating expressions using semi-colons. The\nlast expression, which represents the value returned, can have a\ndifferent type to ",Object(r.b)("inlineCode",{parentName:"p"},"unit"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=a",group:"a"}),"let m (x : int) =\n  begin\n    assert (x > 0);\n    assert (x < 10);\n    x\n  end\n"))),Object(r.b)(o.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("p",null,"In ReasonLIGO, the unique value of the ",Object(r.b)("inlineCode",{parentName:"p"},"unit")," type is ",Object(r.b)("inlineCode",{parentName:"p"},"()"),", following\nthe OCaml convention."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=a",group:"a"}),"let n : unit = ();\n")),Object(r.b)("p",null,"Sequences of expressions that return the ",Object(r.b)("inlineCode",{parentName:"p"},"unit")," type can be written\nusing braces, separating expressions using semi-colons. The last\nexpression, which represents the value returned, can have a different\ntype to ",Object(r.b)("inlineCode",{parentName:"p"},"unit"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=a",group:"a"}),"let m = (x : int) =>\n  { assert (x > 0);\n    assert (x < 10);\n    x }\n"))),Object(r.b)(o.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("p",null,"In JsLIGO, the unique value of the ",Object(r.b)("inlineCode",{parentName:"p"},"unit")," type is ",Object(r.b)("inlineCode",{parentName:"p"},"unit"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=a",group:"a"}),"let n : unit = unit;\n"))),Object(r.b)("h2",{id:"variant-types"},"Variant types"),Object(r.b)("p",null,"A variant type is a user-defined or a built-in type (in case of\noptions) that defines a type by cases, so a value of a variant type is\neither this, or that or... The simplest variant type is equivalent to\nthe enumerated types found in Java, C++, JavaScript etc."),Object(r.b)("p",null,"Here is how we define a coin as being either head or tail (and nothing\nelse):"),Object(r.b)(o.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=b",group:"b"}),"type coin is Head | Tail\nconst head : coin = Head\nconst tail : coin = Tail\n"))),Object(r.b)(o.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=b",group:"b"}),"type coin = Head | Tail\nlet head : coin = Head\nlet tail : coin = Tail\n"))),Object(r.b)(o.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=b",group:"b"}),"type coin = Head | Tail;\nlet head : coin = Head;\nlet tail : coin = Tail;\n"))),Object(r.b)(o.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=b",group:"b"}),'type coin = ["Head"] | ["Tail"];\nlet head: coin = Head();\nlet tail: coin = Tail();\n'))),Object(r.b)("p",null,"The names ",Object(r.b)("inlineCode",{parentName:"p"},"Head")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Tail")," in the definition of the type ",Object(r.b)("inlineCode",{parentName:"p"},"coin")," are\ncalled ",Object(r.b)("em",{parentName:"p"},"data constructors"),", or ",Object(r.b)("em",{parentName:"p"},"variants"),". In this particular, they\ncarry no information beyond their names, so they are called ",Object(r.b)("em",{parentName:"p"},"constant\nconstructors"),"."),Object(r.b)("p",null,"In general, it is interesting for variants to carry some information,\nand thus go beyond enumerated types. In the following, we show how to\ndefine different kinds of users of a system."),Object(r.b)(o.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=c",group:"c"}),"type id is nat\n\ntype user is\n  Admin   of id\n| Manager of id\n| Guest\n\nconst u : user = Admin (1000n)\nconst g : user = Guest\n")),Object(r.b)("p",null,"In PascaLIGO, a constant constructor is equivalent to the same constructor\ntaking an argument of type ",Object(r.b)("inlineCode",{parentName:"p"},"unit"),", so, for example, ",Object(r.b)("inlineCode",{parentName:"p"},"Guest")," is the\nsame value as ",Object(r.b)("inlineCode",{parentName:"p"},"Guest (unit)"),".")),Object(r.b)(o.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=c",group:"c"}),"type id = nat\n\ntype user =\n  Admin   of id\n| Manager of id\n| Guest\n\nlet u : user = Admin 1000n\nlet g : user = Guest\n")),Object(r.b)("p",null,"In CameLIGO, a constant constructor is equivalent to the same constructor\ntaking an argument of type ",Object(r.b)("inlineCode",{parentName:"p"},"unit"),", so, for example, ",Object(r.b)("inlineCode",{parentName:"p"},"Guest")," is the\nsame value as ",Object(r.b)("inlineCode",{parentName:"p"},"Guest ()"),".")),Object(r.b)(o.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=c",group:"c"}),"type id = nat;\n\ntype user =\n| Admin   (id)\n| Manager (id)\n| Guest;\n\nlet u : user = Admin (1000n);\nlet g : user = Guest;\n")),Object(r.b)("p",null,"In ReasonLIGO, a constant constructor is equivalent to the same constructor\ntaking an argument of type ",Object(r.b)("inlineCode",{parentName:"p"},"unit"),", so, for example, ",Object(r.b)("inlineCode",{parentName:"p"},"Guest")," is the\nsame value as ",Object(r.b)("inlineCode",{parentName:"p"},"Guest (unit)"),".")),Object(r.b)(o.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=c",group:"c"}),'type id = nat;\n\ntype user =\n  ["Admin", id]\n| ["Manager", id]\n| ["Guest"];\n\nlet u : user = Admin(1000 as nat);\nlet g : user = Guest();\n')),Object(r.b)("p",null,"In JsLIGO, a constant constructor is equivalent to the same constructor\ntaking an argument of type ",Object(r.b)("inlineCode",{parentName:"p"},"unit"),", so, for example, ",Object(r.b)("inlineCode",{parentName:"p"},"Guest ()")," is the\nsame value as ",Object(r.b)("inlineCode",{parentName:"p"},"Guest (unit)"),".")),Object(r.b)("h2",{id:"optional-values"},"Optional values"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"option")," type is a predefined variant type that is used to express\nwhether there is a value of some type or none. This is especially\nuseful when calling a ",Object(r.b)("em",{parentName:"p"},"partial function"),", that is, a function that is\nnot defined for some inputs. In that case, the value of the ",Object(r.b)("inlineCode",{parentName:"p"},"option"),"\ntype would be ",Object(r.b)("inlineCode",{parentName:"p"},"None"),", otherwise ",Object(r.b)("inlineCode",{parentName:"p"},"Some (v)"),", where ",Object(r.b)("inlineCode",{parentName:"p"},"v")," is some\nmeaningful value ",Object(r.b)("em",{parentName:"p"},"of any type"),". An example in arithmetic is the\ndivision operation:"),Object(r.b)(o.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=d",group:"d"}),"function div (const a : nat; const b : nat) : option (nat) is\n  if b = 0n then (None: option (nat)) else Some (a/b)\n"))),Object(r.b)(o.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=d",group:"d"}),"let div (a, b : nat * nat) : nat option =\n  if b = 0n then (None: nat option) else Some (a/b)\n"))),Object(r.b)(o.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=d",group:"d"}),"let div = ((a, b) : (nat, nat)) : option (nat) =>\n  if (b == 0n) { (None: option (nat)); } else { Some (a/b); };\n"))),Object(r.b)(o.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=d",group:"d"}),"let div = ([a, b]: [nat, nat]): option<nat> => {\n  if(b == (0 as nat)){ \n    return (None() as option <nat>); \n  } else { \n    return (Some (a/b)); \n  };\n};\n"))),Object(r.b)("h2",{id:"pattern-matching"},"Pattern matching"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Pattern matching")," is similar to the ",Object(r.b)("inlineCode",{parentName:"p"},"switch")," construct in\nJavaScript, and can be used to route the program's control flow based\non the value of a variant, record, tuple, or list."),Object(r.b)("p",null,"A component of a pattern can be discarded by using a wildcard ",Object(r.b)("inlineCode",{parentName:"p"},"_"),"\ninstead of a variable name."),Object(r.b)("p",null,"LIGO will warn about unused variables bound in patterns in the same\nway that function arguments are warned about. Variable names beginning\nwith ",Object(r.b)("inlineCode",{parentName:"p"},"_")," can be used as a binder to prevent warnings."),Object(r.b)(o.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"Note: Support for pattern matching isn't yet stable for ReasonLIGO."))),Object(r.b)(o.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"Note: JsLIGO only supports basic pattern matching at the moment. This will change in the future."))),Object(r.b)("h3",{id:"match-on-variants"},"Match on variants"),Object(r.b)("p",null,"Here is a function that transforms a colour variant type to an int."),Object(r.b)(o.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=pm_variant",group:"pm_variant"}),"type color is\n  | RGB   of int * int * int\n  | Gray  of int \n  | Default\n\nfunction int_of_color (const c : color) : int is\n  case c of\n  | RGB (r,g,b) -> 16 + b + g * 6 + r * 36\n  | Gray (i) -> 232 + i\n  | Default -> 0\n  end\n"))),Object(r.b)(o.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=pm_variant",group:"pm_variant"}),"type color =\n  | RGB   of int * int * int\n  | Gray  of int \n  | Default\n\nlet int_of_color (c : color) : int =\n  match c with\n  | RGB (r,g,b) -> 16 + b + g * 6 + r * 36\n  | Gray i -> 232 + i\n  | Default -> 0\n"))),Object(r.b)(o.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=pm_variant",group:"pm_variant"}),"type color =\n  | RGB  ((int, int, int))\n  | Gray (int)\n  | Default\n\nlet int_of_color = (c : color) : int =>\n  switch (c) {\n  | RGB (r,g,b) => (16 + b + g * 6 + r * 36)\n  | Gray i => 232 + i\n  | Default => 0\n  };\n"))),Object(r.b)(o.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=pm_variant",group:"pm_variant"}),'type color =\n| ["RGB", [int, int, int]]\n| ["Gray", int]\n| ["Default"];\n\nlet int_of_color = (c : color) : int =>\n  match(c, {\n    RGB: (rgb : [int,int,int]) => 16 + rgb[2] + rgb[1] * 6 + rgb[0] * 36,\n    Gray: (i : int) => 232 + i,\n    Default: () => 0 });\n'))),Object(r.b)("h3",{id:"match-on-records-or-tuples"},"Match on records or tuples"),Object(r.b)("p",null,"Fields of records and components of tuples can be destructured. Record pattern variables can be renamed."),Object(r.b)(o.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=pm_rec_tuple",group:"pm_rec_tuple"}),"type my_record = { a : int ; b : nat ; c : string }\ntype my_tuple = int * nat * string\n\nlet on_record (v : my_record) : int =\n  match v with\n  | { a ; b = b_renamed ; c = _ } -> a + int(b_renamed)\n\nlet on_tuple (v : my_tuple) : int =\n  match v with\n  | ( x , y , _ ) -> x + int(y)\n"))),Object(r.b)(o.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=pm_rec_tuple",group:"pm_rec_tuple"}),"type my_record is record [ a : int ; b : nat ; c : string ]\ntype my_tuple is (int * nat * string)\n\nfunction on_record (const v : my_record) : int is\n  case v of\n   record [ a ; b = b_renamed ; c = _ ] -> a + int(b_renamed)\n  end\n\nfunction on_tuple (const v : my_tuple) : int is\n  case v of\n  | ( x , y , _ ) -> x + int(y)\n  end\n"))),Object(r.b)(o.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"skip",skip:!0}),"type my_record = { a : int , b : nat , c : string } ;\ntype my_tuple = ( int , nat , string ) ;\n\nlet on_record = (v : my_record) : int =>\n  switch v {\n  | { a , b : b_renamed , c : _ } => a + int(b_renamed)\n  };\n\nlet on_tuple = (v : my_tuple) : int =>\n  switch v {\n  | (x,y,_) => x + int(y)\n  };\n"))),Object(r.b)(o.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("p",null,"Pattern-matching on records and tuples are not supported in JsLIGO yet.")),Object(r.b)("h3",{id:"match-on-lists"},"Match on lists"),Object(r.b)(o.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=pm_lists",group:"pm_lists"}),"let weird_length (v : int list) : int =\n  match v with \n  | [] -> -1\n  | [ a; b ; c] -> -2\n  | x -> int (List.length x)\n"))),Object(r.b)(o.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=pm_lists",group:"pm_lists"}),"function weird_length (const v : list(int)) : int is\n  case v of \n  | nil -> -1\n  | list [ a; b ; c] -> -2\n  | x -> int (List.length (x))\n  end\n"))),Object(r.b)(o.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"skip",skip:!0}),"let weird_length = (v : list(int)) : int =>\n  switch v {\n  | [] => 1\n  | [a,b,c] => -2\n  | x => int (List.length (x))\n  }\n\n"))),Object(r.b)(o.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=pm_lists",group:"pm_lists"}),"let weird_length = (v : list<int>) : int =>\n  match(v, list([\n    ([] : list<int>) => -1,\n    ([hd, ...tl] : list<int>) => 1 + int(List.length(tl))\n  ]));\n"))),Object(r.b)("h3",{id:"deep-patterns"},"Deep patterns"),Object(r.b)("p",null,"Pattern matching can also be used for nested patterns."),Object(r.b)(o.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=pm_complex",group:"pm_complex"}),"type complex_t = { a : int list option ; b : int list }\n\n\nlet complex = fun (x:complex_t) (y:complex_t) ->\n  match (x,y) with\n  | {a=None;b=_} , { a = _ ; b = _ } -> -1\n  | {a=_;b=_} , { a = Some ([]) ; b = (hd::tl) } -> hd\n  | {a=_;b=_} , { a = Some (hd::tl) ; b = [] } -> hd\n  | {a=Some a;b=_} , _ -> int (List.length a)\n"))),Object(r.b)(o.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=pm_complex",group:"pm_complex"}),"type complex_t is record [ a : option(list(int)) ; b : list(int) ]\n\nfunction complex (const x:complex_t ; const y:complex_t) is\n  case (x,y) of\n  | (record [ a=None;b=_] , record [ a = _ ; b = _ ]) -> -1\n  | (record [ a=_;b=_]    , record [ a = Some (nil) ; b = (hd#tl) ]) -> hd\n  | (record [ a=_;b=_]    , record [ a = Some ((hd#tl)) ; b = nil ]) -> hd\n  | (record [ a=Some (a);b=_] , _) -> int ( List.length(a) )\n  end\n"))),Object(r.b)(o.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"skip",skip:!0}),"// let t13 = \n//   ((x: recordi) => \n//      ((y: recordi) => \n//         switch (x, y) {\n//         | {a : None, b : _ }, {a : _, b : _ } => -1\n//         | { a : _, b : _ }, {a : Some [], b : [hd, ...tl] } =>\n//             hd\n//         | { a : _, b = _ }, {a : Some [hd, ...tl], b : [] } =>\n//             hd\n//         | { a : Some a, b : _}, _ => int(Bytes.length(a))\n//         }));\n"))))}b.isMDXComponent=!0},457:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return d}));var a=t(0),i=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=i.a.createContext({}),p=function(e){var n=i.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},b=function(e){var n=p(e.components);return i.a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},m=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),b=p(t),m=a,d=b["".concat(o,".").concat(m)]||b[m]||u[m]||r;return t?i.a.createElement(d,c(c({ref:n},s),{},{components:t})):i.a.createElement(d,c({ref:n},s))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=m;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var s=2;s<r;s++)o[s]=t[s];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},458:function(e,n,t){"use strict";var a=t(0),i=t.n(a).a.createContext("pascaligo");n.a=i},459:function(e,n,t){"use strict";var a=t(0),i=t.n(a),r=t(458);t.d(n,"a",(function(){return r.a})),n.b=function(e){return i.a.createElement(r.a.Consumer,null,(function(n){return n===e.syntax?e.children:i.a.createElement(i.a.Fragment,null)}))}}}]);