(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{457:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),p=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},b=function(e){var t=p(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=p(n),u=a,m=b["".concat(i,".").concat(u)]||b[u]||d[u]||r;return n?o.a.createElement(m,l(l({ref:t},c),{},{components:n})):o.a.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},458:function(e,t,n){"use strict";var a=n(0),o=n.n(a).a.createContext("pascaligo");t.a=o},459:function(e,t,n){"use strict";var a=n(0),o=n.n(a),r=n(458);n.d(t,"a",(function(){return r.a})),t.b=function(e){return o.a.createElement(r.a.Consumer,null,(function(t){return t===e.syntax?e.children:o.a.createElement(o.a.Fragment,null)}))}},91:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(3),o=n(7),r=(n(0),n(457)),i=n(459),l={id:"modules",title:"Modules"},s={unversionedId:"language-basics/modules",id:"version-0.25.0/language-basics/modules",isDocsHomePage:!1,title:"Modules",description:"Note that in JsLIGO modules are called namespaces.",source:"@site/versioned_docs/version-0.25.0/language-basics/modules.md",slug:"/language-basics/modules",permalink:"/docs/language-basics/modules",version:"0.25.0",sidebar:"version-0.25.0/docs",previous:{title:"Exceptions",permalink:"/docs/language-basics/exceptions"},next:{title:"Tezos Domain-Specific Operations",permalink:"/docs/language-basics/tezos-specific"}},c=[{value:"Declaring Modules",id:"declaring-modules",children:[]},{value:"Using Modules",id:"using-modules",children:[]},{value:"Nested Modules: Sub-Modules",id:"nested-modules-sub-modules",children:[]},{value:"Modules and Imports: Build System",id:"modules-and-imports-build-system",children:[]},{value:"Module Aliases",id:"module-aliases",children:[]}],p={toc:c};function b(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"Note that in JsLIGO modules are called ",Object(r.b)("inlineCode",{parentName:"p"},"namespaces"),"."))),Object(r.b)("p",null,"Modules are a programming language construction that allows us to\npackage related definitions together. A canonical example of a module\nis a data type and associated operations over it (e.g. stacks or\nqueues). The rest of the program can access these definitions in a\nregular and abstract way, providing maintainability, reusability and\nsafety."),Object(r.b)("p",null,"For a concrete example, we could create a module that packages a type\nthat represents amounts in a particular currency together with\nfunctions that manipulate these amounts: constants, addition,\nsubtraction, etc. A piece of code that uses this module can be\nagnostic concerning how the type is actually represented inside the\nmodule: it's abstract."),Object(r.b)("h2",{id:"declaring-modules"},"Declaring Modules"),Object(r.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("p",null,"Modules are introduced using the ",Object(r.b)("inlineCode",{parentName:"p"},"module")," keyword. For example, the\nfollowing code defines a module ",Object(r.b)("inlineCode",{parentName:"p"},"EURO")," that packages together a type,\ncalled ",Object(r.b)("inlineCode",{parentName:"p"},"t"),", together with an operation ",Object(r.b)("inlineCode",{parentName:"p"},"add")," that sums two values of\nthe given currency, as well as constants for zero and one."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=EURO",group:"EURO"}),"module EURO is {\n    type t is nat\n    function add (const a : t; const b : t) : t is a + b\n    const zero : t = 0n\n    const one : t = 1n\n}\n"))),Object(r.b)(i.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("p",null,"Modules are introduced using the ",Object(r.b)("inlineCode",{parentName:"p"},"module")," keyword. For example, the\nfollowing code defines a module ",Object(r.b)("inlineCode",{parentName:"p"},"EURO")," that packages together a type,\ncalled ",Object(r.b)("inlineCode",{parentName:"p"},"t"),", together with an operation ",Object(r.b)("inlineCode",{parentName:"p"},"add")," that sums two values of\nthe given currency, as well as constants for zero and one."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=EURO",group:"EURO"}),"module EURO = struct\n    type t = nat\n    let add (a , b : t * t) : t = a + b\n    let zero : t = 0n\n    let one : t = 1n\nend\n")),Object(r.b)("p",null,"As we can see, in CameLIGO we also use a ",Object(r.b)("inlineCode",{parentName:"p"},"struct ... end")," block to\ngroup together the definitions made in the module.")),Object(r.b)(i.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("p",null,"Modules are introduced using the ",Object(r.b)("inlineCode",{parentName:"p"},"module")," keyword. For example, the\nfollowing code defines a module ",Object(r.b)("inlineCode",{parentName:"p"},"EURO")," that packages together a type,\ncalled ",Object(r.b)("inlineCode",{parentName:"p"},"t"),", together with an operation ",Object(r.b)("inlineCode",{parentName:"p"},"add")," that sums two values of\nthe given currency, as well as constants for zero and one."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=EURO",group:"EURO"}),"module EURO = {\n    type t = nat\n    let add = ((a, b) : (t, t)) : t => a + b\n    let zero : t = 0n\n    let one : t = 1n\n}\n"))),Object(r.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("p",null,"Modules are introduced using the ",Object(r.b)("inlineCode",{parentName:"p"},"namespace")," keyword. For example, the\nfollowing code defines a module ",Object(r.b)("inlineCode",{parentName:"p"},"EURO")," that packages together a type,\ncalled ",Object(r.b)("inlineCode",{parentName:"p"},"t"),", together with an operation ",Object(r.b)("inlineCode",{parentName:"p"},"add")," that sums two values of\nthe given currency, as well as constants for zero and one."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=EURO",group:"EURO"}),"namespace EURO {\n    export type t = nat;\n    export let add = ([a, b]: [t, t]): t => a + b;\n    export let zero: t = 0 as nat;\n    export let one: t = 1 as nat\n}\n")),Object(r.b)("p",null,"In this example you will also notice the ",Object(r.b)("inlineCode",{parentName:"p"},"export")," keyword. A statement within a\nmodule can be accessed from outside the module if it is exported."),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"In the experimental version of JsLIGO everything is public by default, so\nalso the statements that are not exported. This will change in the future to\nmatch JavaScript's behaviour."))),Object(r.b)("h2",{id:"using-modules"},"Using Modules"),Object(r.b)("p",null,"We can access a module's components by using the ",Object(r.b)("inlineCode",{parentName:"p"},".")," operator. Let's\nsuppose that our storage keeps a value in euros using the previously\ndefined module ",Object(r.b)("inlineCode",{parentName:"p"},"EURO"),". Then, we can write a ",Object(r.b)("inlineCode",{parentName:"p"},"main")," entry point that\nincrements the storage value each time it is called."),Object(r.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=EURO",group:"EURO"}),"type storage is EURO.t\n\nfunction main (const action : unit; const store : storage) : (list (operation)) * storage is\n ((nil : list (operation)), EURO.add(store, EURO.one))\n"))),Object(r.b)(i.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=EURO",group:"EURO"}),"type storage = EURO.t\n\nlet main (action, store : unit * storage) : operation list * storage =\n (([] : operation list), EURO.add(store, EURO.one))\n"))),Object(r.b)(i.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=EURO",group:"EURO"}),"type storage = EURO.t\n\nlet main = ((action, store) : (unit, storage)) : (list (operation), storage) =>\n (([] : list (operation)), EURO.add(store, EURO.one))\n"))),Object(r.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=EURO",group:"EURO"}),"type storage = EURO.t;\n\nlet main = ([action, store]: [unit, storage]): [list<operation>, storage] =>\n [list([]) as list<operation>, EURO.add(store, EURO.one)];\n"))),Object(r.b)("p",null,"In principle, we could change the implementation of ",Object(r.b)("inlineCode",{parentName:"p"},"EURO"),", without\nhaving to change the ",Object(r.b)("inlineCode",{parentName:"p"},"storage")," type or the function ",Object(r.b)("inlineCode",{parentName:"p"},"main"),". For\nexample, if we decide later that we should support manipulating\nnegative values, we could change ",Object(r.b)("inlineCode",{parentName:"p"},"EURO")," as follows:"),Object(r.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=EURO2",group:"EURO2"}),"module EURO is {\n    type t is int\n    function add (const a : t; const b : t) : t is a + b\n    const zero : t = 0\n    const one : t = 1\n}\n"))),Object(r.b)(i.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=EURO2",group:"EURO2"}),"module EURO = struct\n    type t = int\n    let add (a , b : t * t) : t = a + b\n    let zero : t = 0\n    let one : t = 1\nend\n"))),Object(r.b)(i.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=EURO2",group:"EURO2"}),"module EURO = {\n    type t = int\n    let add = ((a, b) : (t, t)) : t => a + b\n    let zero : t = 0\n    let one : t = 1\n}\n"))),Object(r.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=EURO2",group:"EURO2"}),"namespace EURO {\n    export type t = int;\n    export let add = ([a, b]: [t, t]): t => a + b;\n    export let zero: t = 0;\n    export let one: t = 1;\n}\n"))),Object(r.b)("p",null,"Notice that the code in ",Object(r.b)("inlineCode",{parentName:"p"},"main")," still works, and no change is\nneeded. Abstraction accomplished!"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"\u26a0\ufe0f Please note that code using the module ",Object(r.b)("inlineCode",{parentName:"p"},"EURO")," might still break\nthe abstraction if it directly uses the underlying representation of\n",Object(r.b)("inlineCode",{parentName:"p"},"EURO.t"),". Client code should always try to respect the interface\nprovided by the module, and not make assumptions on its current\nunderlying representation (e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"EURO.t")," is an alias of ",Object(r.b)("inlineCode",{parentName:"p"},"nat"),").")),Object(r.b)("h2",{id:"nested-modules-sub-modules"},"Nested Modules: Sub-Modules"),Object(r.b)("p",null,"Modules can be nested, which means that we can define a module inside\nanother module. Let's see how that works, and define a variant of\n",Object(r.b)("inlineCode",{parentName:"p"},"EURO")," in which the constants are all grouped inside using a sub-module."),Object(r.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=EURO3",group:"EURO3"}),"module EURO is {\n    type t is nat\n    function add (const a : t; const b : t) : t is a + b\n    module CONST is {\n        const zero : t = 0n\n        const one : t = 1n\n    }\n}\n"))),Object(r.b)(i.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=EURO3",group:"EURO3"}),"module EURO = struct\n    type t = nat\n    let add (a, b : t * t) : t = a + b\n    module CONST = struct\n        let zero : t = 0n\n        let one : t = 1n\n    end\nend\n"))),Object(r.b)(i.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=EURO3",group:"EURO3"}),"module EURO = {\n    type t = nat\n    let add = ((a, b) : (t, t)) : t => a + b\n    module CONST = {\n        let zero : t = 0n\n        let one : t = 1n\n    }\n}\n"))),Object(r.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=EURO3",group:"EURO3"}),"namespace EURO {\n    export type t = nat;\n    export let add = ([a, b]: [t, t]): t => a + b;\n    export namespace CONST {\n        export let zero: t = 0 as nat;\n        export let one: t = 1 as nat;\n    };\n};\n"))),Object(r.b)("p",null,"To access nested modules we simply apply the accessor operator more\nthan once:"),Object(r.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=EURO3",group:"EURO3"}),"type storage is EURO.t\n\nfunction main (const action : unit; const store : storage) : (list (operation)) * storage is\n ((nil : list (operation)), EURO.add(store, EURO.CONST.one))\n"))),Object(r.b)(i.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=EURO3",group:"EURO3"}),"type storage = EURO.t\n\nlet main (action, store : unit * storage) : operation list * storage =\n (([] : operation list), EURO.add(store, EURO.CONST.one))\n"))),Object(r.b)(i.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=EURO3",group:"EURO3"}),"type storage = EURO.t\n\nlet main = ((action, store) : (unit, storage)) : (list (operation), storage) =>\n (([] : list (operation)), EURO.add(store, EURO.CONST.one))\n"))),Object(r.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=EURO3",group:"EURO3"}),"type storage = EURO.t;\n\nlet main = ([action, store]: [unit, storage]) : [list<operation>, storage] =>\n [list([]) as list<operation>, EURO.add(store, EURO.CONST.one)]\n"))),Object(r.b)("h2",{id:"modules-and-imports-build-system"},"Modules and Imports: Build System"),Object(r.b)("p",null,"Modules also allow us to separate our code in different files: when we\nimport a file, we obtain a module encapsulating all the definitions in\nit. This will become very handy for organising large contracts, as we\ncan divide it into different files, and the module system keeps the naming\nspace clean."),Object(r.b)("p",null,"Generally, we will take a set of definitions that can be naturally\ngrouped by functionality, and put them together in a separate\nfile."),Object(r.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("p",null,"For example, in PascaLIGO, we can create a file ",Object(r.b)("inlineCode",{parentName:"p"},"imported.ligo"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=imported",group:"imported"}),"type t is nat\n\nfunction add (const a : t; const b : t) : t is a + b\n\nconst zero : t = 0n\nconst one : t = 1n\n"))),Object(r.b)(i.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("p",null,"For example, in CameLIGO, we can create a file ",Object(r.b)("inlineCode",{parentName:"p"},"imported.mligo"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=imported",group:"imported"}),"type t = nat\n\nlet add (a , b : t * t) : t = a + b\n\nlet zero : t = 0n\nlet one : t = 1n\n"))),Object(r.b)(i.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("p",null,"For example, in ReasonLIGO, we can create a file ",Object(r.b)("inlineCode",{parentName:"p"},"imported.religo"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=imported",group:"imported"}),"type t = nat\n\nlet add = ((a, b) : (t, t)) : t => a + b\n\nlet zero : t = 0n\nlet one : t = 1n\n"))),Object(r.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("p",null,"For example, in JsLIGO, we can create a file ",Object(r.b)("inlineCode",{parentName:"p"},"imported.jsligo"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=imported",group:"imported"}),"type t = nat;\n\nlet add = ([a, b]: [t, t]): t => a + b;\n\nlet zero: t = 0 as nat;\nlet one: t = 1 as nat;\n"))),Object(r.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("p",null,"Later, in another file, we can import ",Object(r.b)("inlineCode",{parentName:"p"},"imported.ligo")," as a module, and\nuse its definitions. For example, we could create a ",Object(r.b)("inlineCode",{parentName:"p"},"importer.ligo"),"\nthat imports all definitions from ",Object(r.b)("inlineCode",{parentName:"p"},"imported.ligo")," as the module\n",Object(r.b)("inlineCode",{parentName:"p"},"EURO"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"skip",skip:!0}),'#import "imported.ligo" "EURO"\n\ntype storage is EURO.t\n\nfunction main (const action : unit; const store : storage) : (list (operation)) * storage is\n ((nil : list (operation)), EURO.add(store, EURO.one))\n'))),Object(r.b)(i.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("p",null,"Later, in another file, we can import ",Object(r.b)("inlineCode",{parentName:"p"},"imported.mligo")," as a module, and\nuse its definitions. For example, we could create a ",Object(r.b)("inlineCode",{parentName:"p"},"importer.mligo"),"\nthat imports all definitions from ",Object(r.b)("inlineCode",{parentName:"p"},"imported.mligo")," as the module\n",Object(r.b)("inlineCode",{parentName:"p"},"EURO"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"skip",skip:!0}),'#import "imported.mligo" "EURO"\n\ntype storage = EURO.t\n\nlet main (action, store : unit * storage) : operation list * storage =\n (([] : operation list), EURO.add(store, EURO.one))\n'))),Object(r.b)(i.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("p",null,"Later, in another file, we can import ",Object(r.b)("inlineCode",{parentName:"p"},"imported.religo")," as a module, and\nuse its definitions. For example, we could create a ",Object(r.b)("inlineCode",{parentName:"p"},"importer.religo"),"\nthat imports all definitions from ",Object(r.b)("inlineCode",{parentName:"p"},"imported.religo")," as the module\n",Object(r.b)("inlineCode",{parentName:"p"},"EURO"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"skip",skip:!0}),'#import "imported.religo" "EURO"\n\ntype storage = EURO.t\n\nlet main = ((action, store) : (unit, storage)) : (list (operation), storage) =>\n (([] : list (operation)), EURO.add(store, EURO.one))\n'))),Object(r.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("p",null,"Later, in another file, we can import ",Object(r.b)("inlineCode",{parentName:"p"},"imported.jsligo")," as a module, and\nuse its definitions. For example, we could create a ",Object(r.b)("inlineCode",{parentName:"p"},"importer.jsligo"),"\nthat imports all definitions from ",Object(r.b)("inlineCode",{parentName:"p"},"imported.jsligo")," as the module\n",Object(r.b)("inlineCode",{parentName:"p"},"EURO"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"skip",skip:!0}),'#import "imported.religo" "EURO"\n\ntype storage = EURO.t;\n\nlet main = ([action, store]: [unit, storage]): [list<operation>, storage] =>\n  [list([]) as list (operation), EURO.add(store, EURO.one)];\n'))),Object(r.b)("p",null,"We can compile the file that uses the ",Object(r.b)("inlineCode",{parentName:"p"},"#import")," statement directly,\nwithout having to mention the imported file."),Object(r.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo compile-contract gitlab-pages/docs/language-basics/src/modules/importer.ligo main\n"))),Object(r.b)(i.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo compile-contract gitlab-pages/docs/language-basics/src/modules/importer.mligo main\n"))),Object(r.b)(i.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo compile-contract gitlab-pages/docs/language-basics/src/modules/importer.religo main\n"))),Object(r.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo compile-contract gitlab-pages/docs/language-basics/src/modules/importer.jsligo main\n"))),Object(r.b)("h2",{id:"module-aliases"},"Module Aliases"),Object(r.b)("p",null,"LIGO supports module aliases, that is, modules that work as synonyms\nto other (previously defined) modules. This feature can be useful if\nwe could implement a module using a previously defined one, but in the\nfuture, we might need to change it."),Object(r.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=EURO",group:"EURO"}),"module US_DOLLAR is EURO\n"))),Object(r.b)(i.b,{syntax:"cameligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=EURO",group:"EURO"}),"module US_DOLLAR = EURO\n"))),Object(r.b)(i.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=EURO",group:"EURO"}),"module US_DOLLAR = EURO\n"))),Object(r.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=EURO",group:"EURO"}),"import US_DOLLAR = EURO;\n"))))}b.isMDXComponent=!0}}]);