(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{141:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return p})),n.d(t,"default",(function(){return b}));var a=n(3),r=n(7),o=(n(0),n(457)),s=n(459),i={id:"tezos-specific",title:"Tezos Domain-Specific Operations"},c={unversionedId:"language-basics/tezos-specific",id:"version-0.25.0/language-basics/tezos-specific",isDocsHomePage:!1,title:"Tezos Domain-Specific Operations",description:"LIGO is a programming language for writing Tezos smart contracts. It",source:"@site/versioned_docs/version-0.25.0/language-basics/tezos-specific.md",slug:"/language-basics/tezos-specific",permalink:"/docs/language-basics/tezos-specific",version:"0.25.0",sidebar:"version-0.25.0/docs",previous:{title:"Modules",permalink:"/docs/language-basics/modules"},next:{title:"Timestamps, Addresses",permalink:"/docs/advanced/timestamps-addresses"}},p=[{value:"Pack and Unpack",id:"pack-and-unpack",children:[]},{value:"Hashing Keys",id:"hashing-keys",children:[]},{value:"Checking Signatures",id:"checking-signatures",children:[]},{value:"Contract&#39;s Own Address",id:"contracts-own-address",children:[]},{value:"Origination of a contract",id:"origination-of-a-contract",children:[]}],l={toc:p};function b(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"LIGO is a programming language for writing Tezos smart contracts. It\nwould be a little odd if it did not have any Tezos specific\nfunctions. This page will tell you about them."),Object(o.b)("h2",{id:"pack-and-unpack"},"Pack and Unpack"),Object(o.b)("p",null,"As Michelson provides the ",Object(o.b)("inlineCode",{parentName:"p"},"PACK")," and ",Object(o.b)("inlineCode",{parentName:"p"},"UNPACK")," instructions for data\nserialisation, so does LIGO with ",Object(o.b)("inlineCode",{parentName:"p"},"Bytes.pack")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Bytes.unpack"),".  The\nformer serialises Michelson data structures into a binary format, and\nthe latter reverses that transformation. Unpacking may fail, so the\nreturn type of ",Object(o.b)("inlineCode",{parentName:"p"},"Byte.unpack")," is an option that needs to be annotated."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"\u26a0\ufe0f ",Object(o.b)("inlineCode",{parentName:"p"},"PACK")," and ",Object(o.b)("inlineCode",{parentName:"p"},"UNPACK")," are Michelson instructions that are intended\nto be used by people that really know what they are doing. There are\nseveral risks and failure cases, such as unpacking a lambda from an\nuntrusted source or casting the result to the wrong type. Do not use\nthe corresponding LIGO functions without doing your homework first.")),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=a",group:"a"}),"function id_string (const p : string) : option (string) is block {\n  const packed : bytes = Bytes.pack (p)\n} with (Bytes.unpack (packed) : option (string))\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=a",group:"a"}),"let id_string (p : string) : string option =\n  let packed: bytes = Bytes.pack p in\n  (Bytes.unpack packed : string option)\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=a",group:"a"}),"let id_string = (p : string) : option (string) => {\n  let packed : bytes = Bytes.pack (p);\n  (Bytes.unpack(packed) : option (string));\n};\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=a",group:"a"}),"let id_string = (p: string): option<string> => {\n  let packed: bytes = Bytes.pack(p);\n  return (Bytes.unpack(packed) as option<string>);\n};\n"))),Object(o.b)("h2",{id:"hashing-keys"},"Hashing Keys"),Object(o.b)("p",null,"It is often desirable to hash a public key. In Michelson, certain data\nstructures such as maps will not allow the use of the ",Object(o.b)("inlineCode",{parentName:"p"},"key")," type. Even\nif this were not the case, hashes are much smaller than keys, and\nstorage on blockchains comes at a cost premium. You can hash keys with\na predefined functions returning a value of type ",Object(o.b)("inlineCode",{parentName:"p"},"key_hash"),"."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=b",group:"b"}),"function check_hash_key (const kh1 : key_hash; const k2 : key) : bool * key_hash is\n  block {\n    var ret : bool := False;\n    var kh2 : key_hash := Crypto.hash_key (k2);\n    if kh1 = kh2 then ret := True else skip\n  } with (ret, kh2)\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=b",group:"b"}),"let check_hash_key (kh1, k2 : key_hash * key) : bool * key_hash =\n  let kh2 : key_hash = Crypto.hash_key k2 in \n  (kh1 = kh2), kh2\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=b",group:"b"}),"let check_hash_key = ((kh1, k2) : (key_hash, key)) : (bool, key_hash) => {\n  let kh2 : key_hash = Crypto.hash_key (k2);\n  ((kh1 == kh2), kh2);\n};\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=b",group:"b"}),"let check_hash_key = ([kh1, k2]: [key_hash, key]): [bool, key_hash] => {\n  let kh2: key_hash = Crypto.hash_key(k2);\n  return [(kh1 == kh2), kh2];\n};\n"))),Object(o.b)("h2",{id:"checking-signatures"},"Checking Signatures"),Object(o.b)("p",null,"Sometimes a contract will want to check that a message has been signed\nby a particular key. For example, a point-of-sale system might want a\ncustomer to sign a transaction so it can be processed\nasynchronously. You can do this in LIGO using the ",Object(o.b)("inlineCode",{parentName:"p"},"key")," and\n",Object(o.b)("inlineCode",{parentName:"p"},"signature")," types."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"\u26a0\ufe0f There is no way to ",Object(o.b)("em",{parentName:"p"},"generate")," a signed message in LIGO. This is\nbecause that would require storing a private key on chain, at which\npoint it is not... private anymore.")),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=c",group:"c"}),"function check_signature\n    (const pk     : key;\n     const signed : signature;\n     const msg    : bytes) : bool\n  is Crypto.check (pk, signed, msg)\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=c",group:"c"}),"let check_signature (pk, signed, msg : key * signature * bytes) : bool =\n  Crypto.check pk signed msg\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=c",group:"c"}),"let check_signature =\n  ((pk, signed, msg) : (key, signature, bytes)) : bool =>\n  Crypto.check (pk, signed, msg);\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=c",group:"c"}),"let check_signature =\n  ([pk, signed, msg]: [key, signature, bytes]): bool =>\n  Crypto.check(pk, signed, msg);\n"))),Object(o.b)("h2",{id:"contracts-own-address"},"Contract's Own Address"),Object(o.b)("p",null,"Often you want to get the address of the contract being executed. You\ncan do it with ",Object(o.b)("inlineCode",{parentName:"p"},"Tezos.self_address"),"."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"\u26a0\ufe0f Due to limitations in Michelson, ",Object(o.b)("inlineCode",{parentName:"p"},"Tezos.self_address")," in a\ncontract is only allowed at the top-level. Using it in an embedded\nfunction will cause an error.")),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=d",group:"d"}),"const current_addr : address = Tezos.self_address\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=d",group:"d"}),"let current_addr : address = Tezos.self_address\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=d",group:"d"}),"let current_addr : address = Tezos.self_address;\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=d",group:"d"}),"let current_addr: address = Tezos.self_address;\n"))),Object(o.b)("h2",{id:"origination-of-a-contract"},"Origination of a contract"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Tezos.create_contract")," allows you to originate a contract given its code, delegate (if any), initial balance and initial storage.\nThe return value is a pair of type ",Object(o.b)("inlineCode",{parentName:"p"},"(operation * address)"),"."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"\u26a0\ufe0f Due to limitations in Michelson, ",Object(o.b)("inlineCode",{parentName:"p"},"Tezos.create_contract")," first argument\nmust be inlined and must not contain references to free variables")),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=e",group:"e"}),'const origination : operation * address = Tezos.create_contract (\n  function (const p : nat; const s : string): list(operation) * string is ((nil : list(operation)), s),\n  (None : option(key_hash)),\n  3tz,\n  "initial_storage")\n'))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=e",group:"e"}),'let origination : operation * address = Tezos.create_contract\n  (fun (p, s : nat * string) -> (([] : operation list), s))\n  (None: key_hash option) \n  3tz \n  "initial_storage"\n'))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=e",group:"e"}),'let origination : (operation, address) = Tezos.create_contract (\n  ((p, s) : (nat,string)) : (list(operation),string) => (([] : list(operation)), s),\n  None: option(key_hash),\n  3tz,\n  "initial_storage")\n'))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=e",group:"e"}),'let origination : [operation, address] = Tezos.create_contract (\n  ([p, s]: [nat,string]): [list<operation>, string] => [(list([]) as list<operation>), s],\n  None() as option<key_hash>,\n  3 as tez,\n  "initial_storage");\n'))))}b.isMDXComponent=!0},457:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),l=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},b=function(e){var t=l(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},g={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),b=l(n),u=a,d=b["".concat(s,".").concat(u)]||b[u]||g[u]||o;return n?r.a.createElement(d,i(i({ref:t},p),{},{components:n})):r.a.createElement(d,i({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},458:function(e,t,n){"use strict";var a=n(0),r=n.n(a).a.createContext("pascaligo");t.a=r},459:function(e,t,n){"use strict";var a=n(0),r=n.n(a),o=n(458);n.d(t,"a",(function(){return o.a})),t.b=function(e){return r.a.createElement(o.a.Consumer,null,(function(t){return t===e.syntax?e.children:r.a.createElement(r.a.Fragment,null)}))}}}]);