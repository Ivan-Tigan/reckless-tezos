(window.webpackJsonp=window.webpackJsonp||[]).push([[185],{259:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(3),s=n(7),i=(n(0),n(457)),l=n(459),r={id:"sets-lists-tuples",title:"Tuples, Lists, Sets"},o={unversionedId:"language-basics/sets-lists-tuples",id:"version-0.25.0/language-basics/sets-lists-tuples",isDocsHomePage:!1,title:"Tuples, Lists, Sets",description:"Apart from complex data types such as maps and records, LIGO also",source:"@site/versioned_docs/version-0.25.0/language-basics/sets-lists-tuples.md",slug:"/language-basics/sets-lists-tuples",permalink:"/docs/language-basics/sets-lists-tuples",version:"0.25.0",sidebar:"version-0.25.0/docs",previous:{title:"Records and Maps",permalink:"/docs/language-basics/maps-records"},next:{title:"Exceptions",permalink:"/docs/language-basics/exceptions"}},c=[{value:"Tuples",id:"tuples",children:[{value:"Defining Tuples",id:"defining-tuples",children:[]},{value:"Destructuring",id:"destructuring",children:[]},{value:"Destructuring",id:"destructuring-1",children:[]},{value:"Destructuring",id:"destructuring-2",children:[]},{value:"Accessing Components",id:"accessing-components",children:[]}]},{value:"Lists",id:"lists",children:[{value:"Defining Lists",id:"defining-lists",children:[]},{value:"Adding to Lists",id:"adding-to-lists",children:[]},{value:"Accessing list element",id:"accessing-list-element",children:[]},{value:"Functional Iteration over Lists",id:"functional-iteration-over-lists",children:[]}]},{value:"Sets",id:"sets",children:[{value:"Empty Sets",id:"empty-sets",children:[]},{value:"Non-empty Sets",id:"non-empty-sets",children:[]},{value:"Set Membership",id:"set-membership",children:[]},{value:"Cardinal of Sets",id:"cardinal-of-sets",children:[]},{value:"Updating Sets",id:"updating-sets",children:[]},{value:"Functional Iteration over Sets",id:"functional-iteration-over-sets",children:[]}]}],p={toc:c};function b(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Apart from complex data types such as ",Object(i.b)("inlineCode",{parentName:"p"},"maps")," and ",Object(i.b)("inlineCode",{parentName:"p"},"records"),", LIGO also\nfeatures ",Object(i.b)("inlineCode",{parentName:"p"},"tuples"),", ",Object(i.b)("inlineCode",{parentName:"p"},"lists")," and ",Object(i.b)("inlineCode",{parentName:"p"},"sets"),"."),Object(i.b)("h2",{id:"tuples"},"Tuples"),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("p",null,"Tuples gather a given number of values in a specific order and those\nvalues, called ",Object(i.b)("em",{parentName:"p"},"components"),", can be retrieved by their index\n(position).  Probably the most common tuple is the ",Object(i.b)("em",{parentName:"p"},"pair"),". For\nexample, if we were storing coordinates on a two dimensional grid we\nmight use a pair ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)")," to store the coordinates ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"y"),". There\nis a ",Object(i.b)("em",{parentName:"p"},"specific order"),", so ",Object(i.b)("inlineCode",{parentName:"p"},"(y,x)")," is not equal to ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)")," in\ngeneral. The number of components is part of the type of a tuple, so,\nfor example, we cannot add an extra component to a pair and obtain a\ntriple of the same type: ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)")," has always a different type from\n",Object(i.b)("inlineCode",{parentName:"p"},"(x,y,z)"),", whereas ",Object(i.b)("inlineCode",{parentName:"p"},"(y,x)")," might have the same type as ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)"),".")),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("p",null,"Tuples gather a given number of values in a specific order and those\nvalues, called ",Object(i.b)("em",{parentName:"p"},"components"),", can be retrieved by their index\n(position).  Probably the most common tuple is the ",Object(i.b)("em",{parentName:"p"},"pair"),". For\nexample, if we were storing coordinates on a two dimensional grid we\nmight use a pair ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)")," to store the coordinates ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"y"),". There\nis a ",Object(i.b)("em",{parentName:"p"},"specific order"),", so ",Object(i.b)("inlineCode",{parentName:"p"},"(y,x)")," is not equal to ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)")," in\ngeneral. The number of components is part of the type of a tuple, so,\nfor example, we cannot add an extra component to a pair and obtain a\ntriple of the same type: ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)")," has always a different type from\n",Object(i.b)("inlineCode",{parentName:"p"},"(x,y,z)"),", whereas ",Object(i.b)("inlineCode",{parentName:"p"},"(y,x)")," might have the same type as ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)"),".")),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("p",null,"Tuples gather a given number of values in a specific order and those\nvalues, called ",Object(i.b)("em",{parentName:"p"},"components"),", can be retrieved by their index\n(position).  Probably the most common tuple is the ",Object(i.b)("em",{parentName:"p"},"pair"),". For\nexample, if we were storing coordinates on a two dimensional grid we\nmight use a pair ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)")," to store the coordinates ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"y"),". There\nis a ",Object(i.b)("em",{parentName:"p"},"specific order"),", so ",Object(i.b)("inlineCode",{parentName:"p"},"(y,x)")," is not equal to ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)")," in\ngeneral. The number of components is part of the type of a tuple, so,\nfor example, we cannot add an extra component to a pair and obtain a\ntriple of the same type: ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)")," has always a different type from\n",Object(i.b)("inlineCode",{parentName:"p"},"(x,y,z)"),", whereas ",Object(i.b)("inlineCode",{parentName:"p"},"(y,x)")," might have the same type as ",Object(i.b)("inlineCode",{parentName:"p"},"(x,y)"),".")),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("p",null,"Tuples gather a given number of values in a specific order and those\nvalues, called ",Object(i.b)("em",{parentName:"p"},"components"),", can be retrieved by their index\n(position).  Probably the most common tuple is the ",Object(i.b)("em",{parentName:"p"},"pair"),". For\nexample, if we were storing coordinates on a two dimensional grid we\nmight use a pair ",Object(i.b)("inlineCode",{parentName:"p"},"[x, y]")," to store the coordinates ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"y"),". There\nis a ",Object(i.b)("em",{parentName:"p"},"specific order"),", so ",Object(i.b)("inlineCode",{parentName:"p"},"[y, x]")," is not equal to ",Object(i.b)("inlineCode",{parentName:"p"},"[x, y]")," in\ngeneral. The number of components is part of the type of a tuple, so,\nfor example, we cannot add an extra component to a pair and obtain a\ntriple of the same type: ",Object(i.b)("inlineCode",{parentName:"p"},"[x, y]")," has always a different type from\n",Object(i.b)("inlineCode",{parentName:"p"},"[x, y, z]"),", whereas ",Object(i.b)("inlineCode",{parentName:"p"},"[y, x]")," might have the same type as ",Object(i.b)("inlineCode",{parentName:"p"},"[x, y]"),".")),"Like records, tuple components can be of arbitrary types.",Object(i.b)("h3",{id:"defining-tuples"},"Defining Tuples"),Object(i.b)("p",null,"Unlike ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/language-basics/maps-records"}),"a record"),", tuple types do not\nhave to be defined before they can be used. However below we will give\nthem names by ",Object(i.b)("em",{parentName:"p"},"type aliasing"),"."),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=tuple",group:"tuple"}),'type full_name is string * string  // Alias\n\nconst full_name : full_name = ("Alice", "Johnson")\n'))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=tuple",group:"tuple"}),'type full_name = string * string  // Alias\n\nlet full_name : full_name = ("Alice", "Johnson") // Optional parentheses\n'))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=tuple",group:"tuple"}),'type full_name = (string, string);  // Alias\n\nlet full_name : full_name = ("Alice", "Johnson");\n'))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=tuple",group:"tuple"}),'type full_name = [string, string];  // Alias\n\nlet full_name: full_name = ["Alice", "Johnson"];\n'))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("h3",{id:"destructuring"},"Destructuring"),Object(i.b)("p",null,"If we want to get the first and last name of the ",Object(i.b)("inlineCode",{parentName:"p"},"full_name")," type, we can use\ndestructuring. Destructuring a tuple allows you to give names to the elements\ninside the tuple."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=tuple",group:"tuple"}),"let (first_name, last_name) : full_name = full_name\n")),Object(i.b)("p",null,"This also works in functions:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=tuple",group:"tuple"}),"let first_name ((first_name, _): full_name) = first_name\nlet alice = first_name full_name\n")),Object(i.b)("p",null,"Notice that we use the underscore to indicate that we ignore the last element\nof the tuple.")),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("h3",{id:"destructuring-1"},"Destructuring"),Object(i.b)("p",null,"If we want to get the first and last name of the ",Object(i.b)("inlineCode",{parentName:"p"},"full_name")," type, we can use\ndestructuring. Destructuring a tuple allows you to give names to the elements\ninside the tuple."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=tuple",group:"tuple"}),"let (first_name, last_name) : full_name = full_name\n")),Object(i.b)("p",null,"This also works in functions:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=tuple",group:"tuple"}),"let first_name = ((first_name, _): full_name) => first_name\nlet alice = first_name(full_name)\n")),Object(i.b)("p",null,"Notice that we use the underscore to indicate that we ignore the last element\nof the tuple.")),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("h3",{id:"destructuring-2"},"Destructuring"),Object(i.b)("p",null,"If we want to get the first and last name of the ",Object(i.b)("inlineCode",{parentName:"p"},"full_name")," type, we can use\ndestructuring. Destructuring a tuple allows you to give names to the elements\ninside the tuple."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=tuple",group:"tuple"}),"let [first_name, last_name]: full_name = full_name;\n")),Object(i.b)("p",null,"This also works in functions:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=tuple",group:"tuple"}),"let first_name = ([first_name, _]: full_name):string => first_name;\nlet alice = first_name(full_name);\n")),Object(i.b)("p",null,"Notice that we use the underscore to indicate that we ignore the last element\nof the tuple.")),Object(i.b)("h3",{id:"accessing-components"},"Accessing Components"),Object(i.b)("p",null,"Accessing the components of a tuple in OCaml is achieved by\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/language-basics/unit-option-pattern-matching"}),"pattern matching"),". LIGO\ncurrently supports tuple patterns only in the parameters of functions,\nnot in pattern matching. However, we can access components by their\nposition in their tuple, which cannot be done in OCaml. ",Object(i.b)("em",{parentName:"p"},"Tuple\ncomponents are zero-indexed"),", that is, the first component has index\n",Object(i.b)("inlineCode",{parentName:"p"},"0"),"."),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=tuple",group:"tuple"}),"const first_name : string = full_name.0\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=tuple",group:"tuple"}),"let first_name : string = full_name.0\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=tuple",group:"tuple"}),"let first_name : string = full_name[0];\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=tuple",group:"tuple"}),"let first_name: string = full_name[0];\n"))),Object(i.b)("h2",{id:"lists"},"Lists"),Object(i.b)("p",null,"Lists are linear collections of elements of the same type. Linear\nmeans that, in order to reach an element in a list, we must visit all\nthe elements before (sequential access). Elements can be repeated, as\nonly their order in the collection matters. The first element is\ncalled the ",Object(i.b)("em",{parentName:"p"},"head"),", and the sub-list after the head is called the\n",Object(i.b)("em",{parentName:"p"},"tail"),". For those familiar with algorithmic data structure, you can\nthink of a list a ",Object(i.b)("em",{parentName:"p"},"stack"),", where the top is written on the left."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"\ud83d\udca1 Lists are needed when returning operations from a smart\ncontract's main function.")),Object(i.b)("h3",{id:"defining-lists"},"Defining Lists"),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=lists",group:"lists"}),"const empty_list : list (int) = nil // Or list []\nconst my_list : list (int) = list [1; 2; 2] // The head is 1\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=lists",group:"lists"}),"let empty_list : int list = []\nlet my_list : int list = [1; 2; 2] // The head is 1\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=lists",group:"lists"}),"let empty_list : list (int) = [];\nlet my_list : list (int) = [1, 2, 2]; // The head is 1\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=lists",group:"lists"}),"let empty_list: list<int> = list([]);\nlet my_list: list<int> = list([1, 2, 2]); // The head is 1\n"))),Object(i.b)("h3",{id:"adding-to-lists"},"Adding to Lists"),Object(i.b)("p",null,"Lists can be augmented by adding an element before the head (or, in\nterms of stack, by ",Object(i.b)("em",{parentName:"p"},"pushing an element on top"),"). This operation is\nusually called ",Object(i.b)("em",{parentName:"p"},"consing")," in functional languages."),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("p",null,"In PascaLIGO, the ",Object(i.b)("em",{parentName:"p"},"cons operator")," is infix and noted ",Object(i.b)("inlineCode",{parentName:"p"},"#"),". It is not\nsymmetric: on the left lies the element to cons, and, on the right, a\nlist on which to cons. (The symbol is helpfully asymmetric to remind\nyou of that.)"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=lists",group:"lists"}),"const larger_list : list (int) = 5 # my_list // [5;1;2;2]\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("p",null,"In CameLIGO, the ",Object(i.b)("em",{parentName:"p"},"cons operator")," is infix and noted ",Object(i.b)("inlineCode",{parentName:"p"},"::"),". It is not\nsymmetric: on the left lies the element to cons, and, on the right, a\nlist on which to cons."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=lists",group:"lists"}),"let larger_list : int list = 5 :: my_list // [5;1;2;2]\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("p",null,"In ReasonLIGO, the ",Object(i.b)("em",{parentName:"p"},"cons operator")," is infix and noted ",Object(i.b)("inlineCode",{parentName:"p"},", ..."),". It is\nnot symmetric: on the left lies the element to cons, and, on the\nright, a list on which to cons."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=lists",group:"lists"}),"let larger_list : list (int) = [5, ...my_list]; // [5,1,2,2]\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("p",null,"In JsLIGO, the ",Object(i.b)("em",{parentName:"p"},"cons operator")," is infix and noted ",Object(i.b)("inlineCode",{parentName:"p"},", ..."),". It is\nnot symmetric: on the left lies the element to cons, and, on the\nright, a list on which to cons."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=lists",group:"lists"}),"let larger_list: list<int> = list([5, ...my_list]); // [5,1,2,2]\n"))),Object(i.b)("h3",{id:"accessing-list-element"},"Accessing list element"),Object(i.b)("p",null,"You cannot access element directly in list but you can access the first element, the head or the rest of the list, the tail.\nThe two function to access those are ",Object(i.b)("inlineCode",{parentName:"p"},"List.head_opt")," and ",Object(i.b)("inlineCode",{parentName:"p"},"List.tail_opt")),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=lists",group:"lists"}),"const head : option (int) = List.head_opt (my_list) // 1\nconst tail : option (list(int)) = List.tail_opt (my_list) // [2;2]\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=lists",group:"lists"}),"let head : int option = List.head_opt my_list // 1\nlet tail : int list option = List.tail_opt my_list // [2;2]\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=lists",group:"lists"}),"let head : option (int) = List.head_opt (my_list); // 1\nlet tail : option (list (int)) = List.tail_opt (my_list); // [2,2]\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=lists",group:"lists"}),"let head: option<int> = List.head_opt(my_list); // 1\nlet tail: option<list<int>> = List.tail_opt(my_list); // [2,2]\n"))),Object(i.b)("p",null,"However, the canonical way to destructure lists is using ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/language-basics/unit-option-pattern-matching#match-on-lists"}),"pattern\nmatching"),"."),Object(i.b)("h3",{id:"functional-iteration-over-lists"},"Functional Iteration over Lists"),Object(i.b)("p",null,"A ",Object(i.b)("em",{parentName:"p"},"functional iterator")," is a function that traverses a data structure\nand calls in turn a given function over the elements of that structure\nto compute some value. Another approach is possible in PascaLIGO:\n",Object(i.b)("em",{parentName:"p"},"loops")," (see the relevant section)."),Object(i.b)("p",null,"There are three kinds of functional iterations over LIGO lists: the\n",Object(i.b)("em",{parentName:"p"},"iterated operation"),", the ",Object(i.b)("em",{parentName:"p"},"map operation")," (not to be confused with the\n",Object(i.b)("em",{parentName:"p"},"map data structure"),") and the ",Object(i.b)("em",{parentName:"p"},"fold operation"),"."),Object(i.b)("h4",{id:"iterated-operation-over-lists"},"Iterated Operation over Lists"),Object(i.b)("p",null,"The first, the ",Object(i.b)("em",{parentName:"p"},"iterated operation"),", is an iteration over the list\nwith a unit return value. It is useful to enforce certain invariants\non the element of a list, or fail."),Object(i.b)("p",null,"For example you might want to check that each value inside of a list\nis within a certain range, and fail otherwise. The predefined\nfunctional iterator implementing the iterated operation over lists is\ncalled ",Object(i.b)("inlineCode",{parentName:"p"},"List.iter"),"."),Object(i.b)("p",null,"In the following example, a list is iterated to check that all its\nelements (integers) are strictly greater than ",Object(i.b)("inlineCode",{parentName:"p"},"3"),"."),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=lists",group:"lists"}),'function iter_op (const l : list (int)) : unit is\n  block {\n    function iterated (const i : int) : unit is\n      if i > 3 then Unit else (failwith ("Below range.") : unit)\n  } with List.iter (iterated, l)\n'))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=lists",group:"lists"}),"let iter_op (l : int list) : unit =\n  let predicate = fun (i : int) -> assert (i > 3)\n  in List.iter predicate l\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=lists",group:"lists"}),"let iter_op = (l : list (int)) : unit => {\n  let predicate = (i : int) => assert (i > 3);\n  List.iter (predicate, l);\n};\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=lists",group:"lists"}),"let iter_op = (l: list<int>): unit => {\n  let predicate = (i: int): unit => assert(i > 3);\n  List.iter(predicate, l);\n};\n"))),Object(i.b)("h4",{id:"mapped-operation-over-lists"},"Mapped Operation over Lists"),Object(i.b)("p",null,"We may want to change all the elements of a given list by applying to\nthem a function. This is called a ",Object(i.b)("em",{parentName:"p"},"map operation"),", not to be confused\nwith the map data structure. The predefined functional iterator\nimplementing the mapped operation over lists is called ",Object(i.b)("inlineCode",{parentName:"p"},"List.map")," and\nis used as follows."),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=lists",group:"lists"}),"function increment (const i : int): int is i + 1\n\n// Creates a new list with all elements incremented by 1\nconst plus_one : list (int) = List.map (increment, larger_list)\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=lists",group:"lists"}),"let increment (i : int) : int = i + 1\n\n// Creates a new list with all elements incremented by 1\nlet plus_one : int list = List.map increment larger_list\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=lists",group:"lists"}),"let increment = (i : int) : int => i + 1;\n\n// Creates a new list with all elements incremented by 1\nlet plus_one : list (int) = List.map (increment, larger_list);\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=lists",group:"lists"}),"let increment = (i: int): int => i + 1;\n\n// Creates a new list with all elements incremented by 1\nlet plus_one: list<int> = List.map(increment, larger_list);\n"))),Object(i.b)("h4",{id:"folded-operation-over-lists"},"Folded Operation over Lists"),Object(i.b)("p",null,"A ",Object(i.b)("em",{parentName:"p"},"folded operation")," is the most general of iterations. The folded\nfunction takes two arguments: an ",Object(i.b)("em",{parentName:"p"},"accumulator")," and the structure\n",Object(i.b)("em",{parentName:"p"},"element")," at hand, with which it then produces a new accumulator. This\nenables having a partial result that becomes complete when the\ntraversal of the data structure is over. Folding can be done in two\nways, labelled with the directions left and right. One way to tell them\napart is to look where the folded function, and the fold itself, keep\nthe accumulator in their signatures. Take for example a function ",Object(i.b)("inlineCode",{parentName:"p"},"f"),",\na list ",Object(i.b)("inlineCode",{parentName:"p"},"[1; 2; 3; 4; 5]"),", and an accumulator that's just an empty\nlist. A rough approximation of the result of a left fold would look\nlike ",Object(i.b)("inlineCode",{parentName:"p"},"f(f(f(f(f([], 1), 2), 3), 4), 5)"),", while a right fold would\ninstead look like ",Object(i.b)("inlineCode",{parentName:"p"},"f(1, f(2, f(3, f(4, f(5, [])))))"),"."),Object(i.b)("p",null,"The left fold operation has a function signature of\n",Object(i.b)("inlineCode",{parentName:"p"},"List.fold_left (a -> x -> a) -> a -> x list -> a"),", while the right\nfold operation has ",Object(i.b)("inlineCode",{parentName:"p"},"List.fold_right (x -> a -> a) -> x list -> a -> a"),".\nHere is an example of their use."),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=lists",group:"lists"}),"function sum (const acc : int; const i : int): int is acc + i\nconst sum_of_elements : int = List.fold_left (sum, 0, my_list)\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=lists",group:"lists"}),"let sum (acc, i: int * int) : int = acc + i\nlet sum_of_elements : int = List.fold_left sum 0 my_list\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=lists",group:"lists"}),"let sum = ((result, i): (int, int)): int => result + i;\nlet sum_of_elements : int = List.fold_left (sum, 0, my_list);\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=lists",group:"lists"}),"let sum = ([result, i]: [int, int]): int => result + i;\nlet sum_of_elements: int = List.fold (sum, my_list, 0);\n"))),Object(i.b)("h2",{id:"sets"},"Sets"),Object(i.b)("p",null,"Sets are unordered collections of values of the same type, like lists\nare ordered collections. Like the mathematical sets and lists, sets\ncan be empty and, if not, elements of sets in LIGO are ",Object(i.b)("em",{parentName:"p"},"unique"),",\nwhereas they can be repeated in a ",Object(i.b)("em",{parentName:"p"},"list"),"."),Object(i.b)("h3",{id:"empty-sets"},"Empty Sets"),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("p",null,"In PascaLIGO, the notation for sets is similar to that for lists,\nexcept the keyword ",Object(i.b)("inlineCode",{parentName:"p"},"set")," is used before:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sets",group:"sets"}),"const my_set : set (int) = set []\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("p",null,"In CameLIGO, the empty set is denoted by the predefined value\n",Object(i.b)("inlineCode",{parentName:"p"},"Set.empty"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=sets",group:"sets"}),"let my_set : int set = Set.empty\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("p",null,"In ReasonLIGO, the empty set is denoted by the predefined value\n",Object(i.b)("inlineCode",{parentName:"p"},"Set.empty"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=sets",group:"sets"}),"let my_set : set (int) = Set.empty;\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("p",null,"In JsLIGO, the empty set is denoted by the predefined value\n",Object(i.b)("inlineCode",{parentName:"p"},"Set.empty"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=sets",group:"sets"}),"let my_set: set<int> = Set.empty;\n"))),Object(i.b)("h3",{id:"non-empty-sets"},"Non-empty Sets"),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("p",null,"In PascaLIGO, the notation for sets is similar to that for lists,\nexcept the keyword ",Object(i.b)("inlineCode",{parentName:"p"},"set")," is used before:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sets",group:"sets"}),"const my_set : set (int) = set [3; 2; 2; 1]\n")),Object(i.b)("p",null,"You can check that ",Object(i.b)("inlineCode",{parentName:"p"},"2")," is not repeated in ",Object(i.b)("inlineCode",{parentName:"p"},"my_set")," by using the LIGO\ncompiler like this (the output will sort the elements of the set, but\nthat order is not significant for the compiler):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-expr\ngitlab-pages/docs/language-basics/src/sets-lists-tuples/sets.ligo my_set\n# Outputs: { 3 ; 2 ; 1 }\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("p",null,"In CameLIGO, there is no predefined syntactic construct for sets: you\nmust build your set by adding to the empty set. (This is the way in\nOCaml.)"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=sets",group:"sets"}),"let my_set : int set =\n  Set.add 3 (Set.add 2 (Set.add 2 (Set.add 1 (Set.empty : int set))))\n")),Object(i.b)("p",null,"You can check that ",Object(i.b)("inlineCode",{parentName:"p"},"2")," is not repeated in ",Object(i.b)("inlineCode",{parentName:"p"},"my_set")," by using the LIGO\ncompiler like this (the output will sort the elements of the set, but\nthat order is not significant for the compiler):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-expr\ngitlab-pages/docs/language-basics/src/sets-lists-tuples/sets.mligo my_set\n# Outputs: { 3 ; 2 ; 1 }\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("p",null,"In ReasonLIGO, there is no predefined syntactic construct for sets:\nyou must build your set by adding to the empty set. (This is the way\nin OCaml.)"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=sets",group:"sets"}),"let my_set : set (int) =\n  Set.add (3, Set.add (2, Set.add (2, Set.add (1, Set.empty : set (int)))));\n")),Object(i.b)("p",null,"You can check that ",Object(i.b)("inlineCode",{parentName:"p"},"2")," is not repeated in ",Object(i.b)("inlineCode",{parentName:"p"},"my_set")," by using the LIGO\ncompiler like this (the output will sort the elements of the set, but\nthat order is not significant for the compiler):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-expr\ngitlab-pages/docs/language-basics/src/sets-lists-tuples/sets.religo my_set\n# Outputs: { 3 ; 2 ; 1 }\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=sets",group:"sets"}),"let my_set: set<int> =\n  Set.add(3, Set.add(2, Set.add(2, Set.add(1, Set.empty as set<int>))));\n")),Object(i.b)("p",null,"You can check that ",Object(i.b)("inlineCode",{parentName:"p"},"2")," is not repeated in ",Object(i.b)("inlineCode",{parentName:"p"},"my_set")," by using the LIGO\ncompiler like this (the output will sort the elements of the set, but\nthat order is not significant for the compiler):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-expr\ngitlab-pages/docs/language-basics/src/sets-lists-tuples/sets.jsligo my_set\n# Outputs: { 3 ; 2 ; 1 }\n"))),Object(i.b)("h3",{id:"set-membership"},"Set Membership"),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("p",null,"PascaLIGO features a special keyword ",Object(i.b)("inlineCode",{parentName:"p"},"contains")," that operates like an\ninfix operator checking membership in a set."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sets",group:"sets"}),"const contains_3 : bool = my_set contains 3\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("p",null,"In CameLIGO, the predefined predicate ",Object(i.b)("inlineCode",{parentName:"p"},"Set.mem")," tests for membership\nin a set as follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=sets",group:"sets"}),"let contains_3 : bool = Set.mem 3 my_set\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("p",null,"In ReasonLIGO, the predefined predicate ",Object(i.b)("inlineCode",{parentName:"p"},"Set.mem")," tests for membership\nin a set as follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=sets",group:"sets"}),"let contains_3 : bool = Set.mem (3, my_set);\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("p",null,"In JsLIGO, the predefined predicate ",Object(i.b)("inlineCode",{parentName:"p"},"Set.mem")," tests for membership\nin a set as follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=sets",group:"sets"}),"let contains_3: bool = Set.mem(3, my_set);\n"))),Object(i.b)("h3",{id:"cardinal-of-sets"},"Cardinal of Sets"),Object(i.b)("p",null,"The predefined function ",Object(i.b)("inlineCode",{parentName:"p"},"Set.size")," returns the number of\nelements in a given set as follows."),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sets",group:"sets"}),"const cardinal : nat = Set.size (my_set)\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=sets",group:"sets"}),"let cardinal : nat = Set.size my_set\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=sets",group:"sets"}),"let cardinal : nat = Set.size (my_set);\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=sets",group:"sets"}),"let cardinal: nat = Set.size(my_set);\n"))),Object(i.b)("h3",{id:"updating-sets"},"Updating Sets"),Object(i.b)("p",null,"There are two ways to update a set, that is to add or remove from\nit."),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("p",null,"In PascaLIGO, either we create a new set from the given one, or we\nmodify it in-place. First, let us consider the former way:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sets",group:"sets"}),"const larger_set  : set (int) = Set.add (4, my_set)\nconst smaller_set : set (int) = Set.remove (3, my_set)\n")),Object(i.b)("p",null,"If we are in a block, we can use an instruction to modify the set\nbound to a given variable. This is called a ",Object(i.b)("em",{parentName:"p"},"patch"),". It is only\npossible to add elements by means of a patch, not remove any: it is\nthe union of two sets."),Object(i.b)("p",null,"In the following example, the parameter set ",Object(i.b)("inlineCode",{parentName:"p"},"s")," of function ",Object(i.b)("inlineCode",{parentName:"p"},"update"),"\nis augmented (as the ",Object(i.b)("inlineCode",{parentName:"p"},"with s")," shows) to include ",Object(i.b)("inlineCode",{parentName:"p"},"4")," and ",Object(i.b)("inlineCode",{parentName:"p"},"7"),", that is,\nthis instruction is equivalent to perform the union of two sets, one\nthat is modified in-place, and the other given as a literal\n(extensional definition)."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sets",group:"sets"}),"function update (var s : set (int)) : set (int) is block {\n  patch s with set [4; 7]\n} with s\n\nconst new_set : set (int) = update (my_set)\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("p",null,"In CameLIGO, we can use the predefined functions ",Object(i.b)("inlineCode",{parentName:"p"},"Set.add")," and\n",Object(i.b)("inlineCode",{parentName:"p"},"Set.remove"),". We update a given set by creating another one, with or\nwithout some elements."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=sets",group:"sets"}),"let larger_set  : int set = Set.add 4 my_set\nlet smaller_set : int set = Set.remove 3 my_set\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("p",null,"In ReasonLIGO, we can use the predefined functions ",Object(i.b)("inlineCode",{parentName:"p"},"Set.add")," and\n",Object(i.b)("inlineCode",{parentName:"p"},"Set.remove"),". We update a given set by creating another one, with or\nwithout some elements."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=sets",group:"sets"}),"let larger_set  : set (int) = Set.add (4, my_set);\nlet smaller_set : set (int) = Set.remove (3, my_set);\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("p",null,"In JsLIGO, we can use the predefined functions ",Object(i.b)("inlineCode",{parentName:"p"},"Set.add")," and\n",Object(i.b)("inlineCode",{parentName:"p"},"Set.remove"),". We update a given set by creating another one, with or\nwithout some elements."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=sets",group:"sets"}),"let larger_set: set<int> = Set.add(4, my_set);\nlet smaller_set: set<int> = Set.remove(3, my_set);\n"))),Object(i.b)("h3",{id:"functional-iteration-over-sets"},"Functional Iteration over Sets"),Object(i.b)("p",null,"A ",Object(i.b)("em",{parentName:"p"},"functional iterator")," is a function that traverses a data structure\nand calls in turn a given function over the elements of that structure\nto compute some value. Another approach is possible in PascaLIGO:\n",Object(i.b)("em",{parentName:"p"},"loops")," (see the relevant section)."),Object(i.b)("p",null,"There are three kinds of functional iterations over LIGO maps: the\n",Object(i.b)("em",{parentName:"p"},"iterated operation"),", the ",Object(i.b)("em",{parentName:"p"},"mapped operation")," (not to be confused with\nthe ",Object(i.b)("em",{parentName:"p"},"map data structure"),") and the ",Object(i.b)("em",{parentName:"p"},"folded operation"),"."),Object(i.b)("h4",{id:"iterated-operation"},"Iterated Operation"),Object(i.b)("p",null,"The first, the ",Object(i.b)("em",{parentName:"p"},"iterated operation"),", is an iteration over the map with\nno return value: its only use is to produce side-effects. This can be\nuseful if for example you would like to check that each value inside\nof a map is within a certain range, and fail with an error otherwise."),Object(i.b)("p",null,"The predefined functional iterator implementing the iterated operation\nover sets is called ",Object(i.b)("inlineCode",{parentName:"p"},"Set.iter"),". In the following example, a set is\niterated to check that all its elements (integers) are greater than\n",Object(i.b)("inlineCode",{parentName:"p"},"3"),"."),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sets",group:"sets"}),'function iter_op (const s : set (int)) : unit is\n  block {\n    function iterated (const i : int) : unit is\n      if i > 2 then Unit else (failwith ("Below range.") : unit)\n  } with Set.iter (iterated, s)\n'))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=sets",group:"sets"}),"let iter_op (s : int set) : unit =\n  let predicate = fun (i : int) -> assert (i > 3)\n  in Set.iter predicate s\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=sets",group:"sets"}),"let iter_op = (s : set (int)) : unit => {\n  let predicate = (i : int) => assert (i > 3);\n  Set.iter (predicate, s);\n};\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=sets",group:"sets"}),"let iter_op = (s: set<int>): unit => {\n  let predicate = (i: int): unit => assert(i > 3);\n  Set.iter(predicate, s);\n};\n"))),Object(i.b)("h4",{id:"folded-operation"},"Folded Operation"),Object(i.b)("p",null,"A ",Object(i.b)("em",{parentName:"p"},"folded operation")," is the most general of iterations. The folded\nfunction takes two arguments: an ",Object(i.b)("em",{parentName:"p"},"accumulator")," and the structure\n",Object(i.b)("em",{parentName:"p"},"element")," at hand, with which it then produces a new accumulator. This\nenables having a partial result that becomes complete when the\ntraversal of the data structure is over. The predefined fold over sets\nis called ",Object(i.b)("inlineCode",{parentName:"p"},"Set.fold"),", however an additional function, ",Object(i.b)("inlineCode",{parentName:"p"},"Set.fold_right"),",\nhas been added to properly conform to the function signature of OCaml's\n",Object(i.b)("inlineCode",{parentName:"p"},"Set.fold")," operation, and it has the function signature\n",Object(i.b)("inlineCode",{parentName:"p"},"Set.fold_right (x -> a -> a) -> x Set -> a -> a"),"."),Object(i.b)(l.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sets",group:"sets"}),"function sum (const acc : int; const i : int): int is acc + i\nconst sum_of_elements : int = Set.fold (sum, my_set, 0)\n")),Object(i.b)("p",null,"It is possible to use a ",Object(i.b)("em",{parentName:"p"},"loop")," over a set as well."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=sets",group:"sets"}),"function loop (const s : set (int)) : int is block {\n  var sum : int := 0;\n  for element in set s block {\n    sum := sum + element\n  }\n} with sum\n"))),Object(i.b)(l.b,{syntax:"cameligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=sets",group:"sets"}),"let sum (acc, i : int * int) : int = acc + i\nlet sum_of_elements : int = Set.fold sum my_set 0\n"))),Object(i.b)(l.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=sets",group:"sets"}),"let sum = ((acc, i) : (int, int)) : int => acc + i;\nlet sum_of_elements : int = Set.fold (sum, my_set, 0);\n"))),Object(i.b)(l.b,{syntax:"jsligo",mdxType:"Syntax"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=sets",group:"sets"}),"let sum = ([acc, i]: [int, int]): int => acc + i;\nlet sum_of_elements: int = Set.fold(sum, my_set, 0);\n"))))}b.isMDXComponent=!0},457:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return d}));var a=n(0),s=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=s.a.createContext({}),p=function(e){var t=s.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},b=function(e){var t=p(e.components);return s.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},u=s.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),b=p(n),u=a,d=b["".concat(l,".").concat(u)]||b[u]||m[u]||i;return n?s.a.createElement(d,r(r({ref:t},c),{},{components:n})):s.a.createElement(d,r({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=u;var r={};for(var o in t)hasOwnProperty.call(t,o)&&(r[o]=t[o]);r.originalType=e,r.mdxType="string"==typeof e?e:a,l[1]=r;for(var c=2;c<i;c++)l[c]=n[c];return s.a.createElement.apply(null,l)}return s.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},458:function(e,t,n){"use strict";var a=n(0),s=n.n(a).a.createContext("pascaligo");t.a=s},459:function(e,t,n){"use strict";var a=n(0),s=n.n(a),i=n(458);n.d(t,"a",(function(){return i.a})),t.b=function(e){return s.a.createElement(i.a.Consumer,null,(function(t){return t===e.syntax?e.children:s.a.createElement(s.a.Fragment,null)}))}}}]);