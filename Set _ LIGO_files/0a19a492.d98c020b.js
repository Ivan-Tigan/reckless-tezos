(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{457:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return m}));var a=t(0),o=t.n(a);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=o.a.createContext({}),u=function(e){var n=o.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=u(e.components);return o.a.createElement(c.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},g=o.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,i=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=u(t),g=a,m=p["".concat(i,".").concat(g)]||p[g]||b[g]||l;return t?o.a.createElement(m,s(s({ref:n},c),{},{components:t})):o.a.createElement(m,s({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,i=new Array(l);i[0]=g;var s={};for(var r in n)hasOwnProperty.call(n,r)&&(s[r]=n[r]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<l;c++)i[c]=t[c];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},458:function(e,n,t){"use strict";var a=t(0),o=t.n(a).a.createContext("pascaligo");n.a=o},459:function(e,n,t){"use strict";var a=t(0),o=t.n(a),l=t(458);t.d(n,"a",(function(){return l.a})),n.b=function(e){return o.a.createElement(l.a.Consumer,null,(function(n){return n===e.syntax?e.children:o.a.createElement(o.a.Fragment,null)}))}},80:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return r})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return p}));var a=t(3),o=t(7),l=(t(0),t(457)),i=t(459),s={id:"loops",title:"Iteration"},r={unversionedId:"language-basics/loops",id:"version-0.25.0/language-basics/loops",isDocsHomePage:!1,title:"Iteration",description:"General Iteration",source:"@site/versioned_docs/version-0.25.0/language-basics/loops.md",slug:"/language-basics/loops",permalink:"/docs/language-basics/loops",version:"0.25.0",sidebar:"version-0.25.0/docs",previous:{title:"Booleans and Conditionals",permalink:"/docs/language-basics/boolean-if-else"},next:{title:"Unit, Option, Pattern matching",permalink:"/docs/language-basics/unit-option-pattern-matching"}},c=[{value:"General Iteration",id:"general-iteration",children:[]},{value:"Bounded Loops",id:"bounded-loops",children:[]},{value:"for-of Loops",id:"for-of-loops",children:[]}],u={toc:c};function p(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"general-iteration"},"General Iteration"),Object(l.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(l.b)("p",null,'General iteration in PascaLIGO takes the shape of general loops, which\nshould be familiar to programmers of imperative languages as "while\nloops". Those loops are of the form ',Object(l.b)("inlineCode",{parentName:"p"},"while <condition> <block>"),'. Their\nassociated block is repeatedly evaluated until the condition becomes\ntrue, or never evaluated if the condition is false at the start. The\nloop never terminates if the condition never becomes true. Because we\nare writing smart contracts on Tezos, when the condition of a "while"\nloops fails to become true, the execution will run out of gas and stop\nwith a failure anyway.'),Object(l.b)("p",null,"Here is how to compute the greatest common divisors of two natural\nnumbers by means of Euclid's algorithm:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=a",group:"a"}),"function gcd (var x : nat; var y : nat) : nat is\n  block {\n    if x < y then {\n      const z : nat = x;\n      x := y; y := z\n    }\n    else skip;\n    var r : nat := 0n;\n    while y =/= 0n block {\n      r := x mod y;\n      x := y;\n      y := r\n    }\n  } with x\n")),Object(l.b)("p",null,"You can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"gcd")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/gcd.ligo gcd '(2n*2n*3n*11n, 2n*2n*2n*3n*3n*5n*7n)'\n# Outputs: +12\n"))),Object(l.b)(i.b,{syntax:"cameligo",mdxType:"Syntax"},Object(l.b)("p",null,'CameLIGO is a functional language where user-defined values are\nconstant, therefore it makes no sense in CameLIGO to feature loops,\nwhich we understand as syntactic constructs where the state of a\nstopping condition is mutated, as with "while" loops in PascaLIGO.'),Object(l.b)("p",null,"Instead, CameLIGO loops are written by means of a tail recursive function"),Object(l.b)("p",null,"Here is how to compute the greatest common divisors of two natural\nnumbers by means of Euclid's algorithm:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=a",group:"a"}),"let rec iter (x,y : nat * nat) : nat =\n  if y = 0n then x else iter (y, x mod y)\n\nlet gcd (x,y : nat * nat) : nat =\n  let x,y = if x < y then y,x else x,y in\n  iter (x,y)\n")),Object(l.b)("p",null,"You can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"gcd")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/gcd.mligo gcd (2n*2n*3n*11n, 2n*2n*2n*3n*3n*5n*7n)'\n# Outputs: +12\n"))),Object(l.b)(i.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(l.b)("p",null,'ReasonLIGO is a functional language where user-defined values are\nconstant, therefore it makes no sense in ReasonLIGO to feature loops,\nwhich we understand as syntactic constructs where the state of a\nstopping condition is mutated, as with "while" loops in PascaLIGO.'),Object(l.b)("p",null,"Instead, ReasonLIGO loops are written by means of tail recursive functions"),Object(l.b)("p",null,"Here is how to compute the greatest common divisors of two natural\nnumbers by means of Euclid's algorithm:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=a",group:"a"}),"let rec iter = ((x,y) : (nat, nat)) : nat =>\n  if (y == 0n) { x; } else { iter ((y, x mod y)); };\n\nlet gcd = ((x,y) : (nat, nat)) : nat => {\n  let (x,y) = if (x < y) { (y,x); } else { (x,y); };\n  iter ((x,y))\n};\n"))),Object(l.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(l.b)("p",null,"JsLIGO currently supports iteration through while while loops and\nthrough the use of tail recursive functions."),Object(l.b)("p",null,"Here is how to compute the greatest common divisors of two natural\nnumbers by means of Euclid's algorithm with using a while loop:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=a",group:"a"}),"let gcd = (x: nat, y: nat): nat => {\n  let [x,y] = [x,y]; // we will modify x and y\n  if (x < y) {\n    const z: nat = x;\n    x = y; y = z;\n  };\n  let r: nat = 0 as nat;\n  while (y != (0 as nat)) {\n    r = x % y;\n    x = y;\n    y = r;\n  }\n  return x\n}\n")),Object(l.b)("p",null,"And here is how to compute the greatest common divisors of two natural\nnumbers by means of Euclid's algorithm using tail recursion:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=a",group:"a"}),"let iter = ([x,y]: [nat, nat]): nat => {\n  if (y == (0 as nat)) { \n    return x; \n  } else { \n    return iter ([y, x % y]); \n  };\n};\n\nlet gcd2 = ([x,y] : [nat, nat]) : nat => {\n  if (x < y) { \n    return iter ([y, x]);\n  } else {\n    return iter ([x, y]);\n  }\n};\n")),Object(l.b)("p",null,"You can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"gcd")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/gcd.jsligo gcd '(2n*2n*3n*11n, 2n*2n*2n*3n*3n*5n*7n)'\n# Outputs: +12\n")),Object(l.b)("p",null,"and can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"gcd2")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/gcd.jsligo gcd2 '(2n*2n*3n*11n, 2n*2n*2n*3n*3n*5n*7n)'\n# Outputs: +12\n"))),Object(l.b)(i.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(l.b)("h2",{id:"bounded-loops"},"Bounded Loops"),Object(l.b)("p",null,"In addition to general loops, PascaLIGO features a specialised kind of\n",Object(l.b)("em",{parentName:"p"},"loop to iterate over bounded intervals"),'. These loops are familiarly\nknown as "for loops" and they have the form ',Object(l.b)("inlineCode",{parentName:"p"},"for <variable assignment>\nto <upper bound> <block>"),", as found in imperative languages."),Object(l.b)("p",null,"Consider how to sum the natural numbers up to ",Object(l.b)("inlineCode",{parentName:"p"},"n"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=c",group:"c"}),"function sum (var n : nat) : int is block {\n  var acc : int := 0;\n  for i := 1 to int (n) block {\n    acc := acc + i\n  }\n} with acc\n")),Object(l.b)("p",null,"(Please do not use that function: there exists a closed form formula.)"),Object(l.b)("p",null,"You can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"sum")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/sum.ligo sum 7n\n# Outputs: 28\n")),Object(l.b)("p",null,'PascaLIGO "for" loops can also iterate through the contents of a\ncollection, that is, a list, a set or a map. This is done with a loop\nof the form ',Object(l.b)("inlineCode",{parentName:"p"},"for <element var> in <collection type> <collection var> <block>"),",\nwhere ",Object(l.b)("inlineCode",{parentName:"p"},"<collection type>")," is any of the following keywords:\n",Object(l.b)("inlineCode",{parentName:"p"},"list"),", ",Object(l.b)("inlineCode",{parentName:"p"},"set")," or ",Object(l.b)("inlineCode",{parentName:"p"},"map"),"."),Object(l.b)("p",null,"Here is an example where the integers in a list are summed up."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=d",group:"d"}),"function sum_list (var l : list (int)) : int is block {\n  var total : int := 0;\n  for i in list l block {\n    total := total + i\n  }\n} with total\n")),Object(l.b)("p",null,"You can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"sum_list")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/collection.ligo sum_list\n'list [1;2;3]'\n# Outputs: 6\n")),Object(l.b)("p",null,"Here is an example where the integers in a set are summed up."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=d",group:"d"}),"function sum_set (var s : set (int)) : int is block {\n  var total : int := 0;\n  for i in set s block {\n    total := total + i\n  }\n} with total\n")),Object(l.b)("p",null,"You can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"sum_set")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/collection.ligo sum_set\n'set [1;2;3]'\n# Outputs: 6\n")),Object(l.b)("p",null,"Loops over maps are actually loops over the bindings of the map, that\nis, a pair key-value noted ",Object(l.b)("inlineCode",{parentName:"p"},"key -> value")," (or any other\nvariables). Given a map from strings to integers, here is how to sum\nall the integers and concatenate all the strings."),Object(l.b)("p",null,"Here is an example where the keys are concatenated and the values are\nsummed up."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=d",group:"d"}),'function sum_map (var m : map (string, int)) : string * int is block {\n  var string_total : string := "";\n  var int_total : int := 0;\n  for key -> value in map m block {\n    string_total := string_total ^ key;\n    int_total := int_total + value\n  }\n} with (string_total, int_total)\n')),Object(l.b)("p",null,"You can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"sum_map")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/collection.ligo sum_map\n\'map ["1"->1; "2"->2; "3"->3]\'\n# Outputs: ( "123", 6 )\n'))),Object(l.b)(i.b,{syntax:"jsligo",mdxType:"Syntax"},Object(l.b)("h2",{id:"for-of-loops"},"for-of Loops"),Object(l.b)("p",null,'JsLIGO "for-of" loops can iterate through the contents of a\ncollection, that is, a list, a set or a map. This is done with a loop\nof the form ',Object(l.b)("inlineCode",{parentName:"p"},"for (const <element var> of <collection var>) <block>"),"."),Object(l.b)("p",null,"Here is an example where the integers in a list are summed up."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=d",group:"d"}),"let sum_list = (l: list<int>): int => {\n  let total : int = 0;\n  for (const i of l) {\n    total = total + i\n  }\n  return total\n} \n")),Object(l.b)("p",null,"You can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"sum_list")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/collection.jsligo sum_list\n'list [1;2;3]'\n# Outputs: 6\n")),Object(l.b)("p",null,"Here is an example where the integers in a set are summed up."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=d",group:"d"}),"let sum_set = (s: set<int>): int => {\n  let total : int = 0;\n  for (const i of s) {\n    total = total + i\n  };\n  return total\n}\n")),Object(l.b)("p",null,"You can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"sum_set")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/collection.jsligo sum_set\n'set [1;2;3]'\n# Outputs: 6\n")),Object(l.b)("p",null,"Loops over maps are actually loops over the bindings of the map.\nGiven a map from strings to integers, here is how to sum\nall the integers and concatenate all the strings."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsligo",metastring:"skip",skip:!0}),'let sum_map = (m: map<string, int>): [string, int] => {\n  let string_total: string = "";\n  let int_total: int = 0;\n  for (const item of m) {\n    let [key, value] = item;\n    string_total = string_total + key;\n    int_total = int_total + value\n  };\n  return [string_total, int_total]\n}\n')),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"In the experimental version of JsLIGO looping over maps is not supported.\nUse ",Object(l.b)("inlineCode",{parentName:"p"},"Map.iter")," instead.")),Object(l.b)("p",null,"You can call the function ",Object(l.b)("inlineCode",{parentName:"p"},"sum_map")," defined above using the LIGO compiler\nlike so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/loops/collection.jsligo sum_map\n\'map ["1"->1; "2"->2; "3"->3]\'\n# Outputs: ( "123", 6 )\n'))))}p.isMDXComponent=!0}}]);