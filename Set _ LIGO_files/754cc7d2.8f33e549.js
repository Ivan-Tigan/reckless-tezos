(window.webpackJsonp=window.webpackJsonp||[]).push([[193],{267:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return c})),t.d(a,"metadata",(function(){return i})),t.d(a,"toc",(function(){return p})),t.d(a,"default",(function(){return b}));var n=t(3),r=t(7),o=(t(0),t(457)),s=t(459),c={id:"maps-records",title:"Records and Maps"},i={unversionedId:"language-basics/maps-records",id:"version-0.25.0/language-basics/maps-records",isDocsHomePage:!1,title:"Records and Maps",description:"So far, we have seen pretty basic data types. LIGO also offers more",source:"@site/versioned_docs/version-0.25.0/language-basics/maps-records.md",slug:"/language-basics/maps-records",permalink:"/docs/language-basics/maps-records",version:"0.25.0",sidebar:"version-0.25.0/docs",previous:{title:"Unit, Option, Pattern matching",permalink:"/docs/language-basics/unit-option-pattern-matching"},next:{title:"Tuples, Lists, Sets",permalink:"/docs/language-basics/sets-lists-tuples"}},p=[{value:"Records",id:"records",children:[{value:"Accessing Record Fields",id:"accessing-record-fields",children:[]},{value:"Functional Updates",id:"functional-updates",children:[]},{value:"Record Patches",id:"record-patches",children:[]},{value:"Comparison",id:"comparison",children:[]}]},{value:"Maps",id:"maps",children:[{value:"Declaring a Map",id:"declaring-a-map",children:[]},{value:"Creating an Empty Map",id:"creating-an-empty-map",children:[]},{value:"Creating a Non-empty Map",id:"creating-a-non-empty-map",children:[]},{value:"Accessing Map Bindings",id:"accessing-map-bindings",children:[]},{value:"Updating a Map",id:"updating-a-map",children:[]},{value:"Functional Iteration over Maps",id:"functional-iteration-over-maps",children:[]}]},{value:"Big Maps",id:"big-maps",children:[{value:"Declaring a Map",id:"declaring-a-map-1",children:[]},{value:"Creating an Empty Big Map",id:"creating-an-empty-big-map",children:[]},{value:"Creating a Non-empty Map",id:"creating-a-non-empty-map-1",children:[]},{value:"Accessing Values",id:"accessing-values",children:[]},{value:"Updating Big Maps",id:"updating-big-maps",children:[]},{value:"Removing Bindings",id:"removing-bindings",children:[]}]}],l={toc:p};function b(e){var a=e.components,t=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,t,{components:a,mdxType:"MDXLayout"}),Object(o.b)("p",null,"So far, we have seen pretty basic data types. LIGO also offers more\ncomplex built-in constructs, such as ",Object(o.b)("em",{parentName:"p"},"records")," and ",Object(o.b)("em",{parentName:"p"},"maps"),"."),Object(o.b)("h2",{id:"records"},"Records"),Object(o.b)("p",null,"Records are one-way data of different types can be packed into a\nsingle type. A record is made of a set of ",Object(o.b)("em",{parentName:"p"},"fields"),", which are made of\na ",Object(o.b)("em",{parentName:"p"},"field name")," and a ",Object(o.b)("em",{parentName:"p"},"field type"),". Given a value of a record type, the\nvalue bound to a field can be accessed by giving its field name to a\nspecial operator (",Object(o.b)("inlineCode",{parentName:"p"},"."),")."),Object(o.b)("p",null,"Let us first consider an example of record type declaration."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=records1",group:"records1"}),"type user is\n  record [\n    id       : nat;\n    is_admin : bool;\n    name     : string\n  ]\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=records1",group:"records1"}),"type user = {\n  id       : nat;\n  is_admin : bool;\n  name     : string\n}\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=records1",group:"records1"}),"type user = {\n  id       : nat,\n  is_admin : bool,\n  name     : string\n};\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=records1",group:"records1"}),"type user = {\n  id       : nat,\n  is_admin : bool,\n  name     : string\n};\n"))),Object(o.b)("p",null,"And here is how a record value is defined:"),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=records1",group:"records1"}),'const alice : user =\n  record [\n    id       = 1n;\n    is_admin = True;\n    name     = "Alice"\n  ]\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Notice that since ",Object(o.b)("inlineCode",{parentName:"p"},"alice")," is declared as a ",Object(o.b)("inlineCode",{parentName:"p"},"const"),", none of its fields can be updated."))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=records1",group:"records1"}),'let alice : user = {\n  id       = 1n;\n  is_admin = true;\n  name     = "Alice"\n}\n'))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=records1",group:"records1"}),'let alice : user = {\n  id       : 1n,\n  is_admin : true,\n  name     : "Alice"\n};\n'))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=records1",group:"records1"}),'let alice : user = {\n  id       : 1 as nat,\n  is_admin : true,\n  name     : "Alice"\n};\n'))),Object(o.b)("h3",{id:"accessing-record-fields"},"Accessing Record Fields"),Object(o.b)("p",null,"If we want the contents of a given field, we use the (",Object(o.b)("inlineCode",{parentName:"p"},"."),") infix\noperator, like so:"),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=records1",group:"records1"}),"const alice_admin : bool = alice.is_admin\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=records1",group:"records1"}),"let alice_admin : bool = alice.is_admin\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=records1",group:"records1"}),"let alice_admin : bool = alice.is_admin;\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=records1",group:"records1"}),"let alice_admin: bool = alice.is_admin;\n"))),Object(o.b)("h3",{id:"functional-updates"},"Functional Updates"),Object(o.b)("p",null,"Given a record value, it is a common design pattern to update only a\nsmall number of its fields. Instead of copying the fields that are\nunchanged, LIGO offers a way to only update the fields that are\nmodified."),Object(o.b)("p",null,"One way to understand the update of record values is the ",Object(o.b)("em",{parentName:"p"},"functional\nupdate"),". The idea is to have an ",Object(o.b)("em",{parentName:"p"},"expression")," whose value is the\nupdated record."),Object(o.b)("p",null,"Let us consider defining a function that translates three-dimensional\npoints on a plane."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("p",null,"In PascaLIGO, the shape of that expression is\n",Object(o.b)("inlineCode",{parentName:"p"},"<record variable> with <record value>"),".\nThe record variable is the record to update, and the\nrecord value is the update itself."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=records2",group:"records2"}),"type point is record [x : int; y : int; z : int]\ntype vector is record [dx : int; dy : int]\n\nconst origin : point = record [x = 0; y = 0; z = 0]\n\nfunction xy_translate (var p : point; const vec : vector) : point is\n  p with record [x = p.x + vec.dx; y = p.y + vec.dy]\n")),Object(o.b)("p",null,"You can call the function ",Object(o.b)("inlineCode",{parentName:"p"},"xy_translate")," defined above by running the\nfollowing command of the shell:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/maps-records/record_update.ligo\nxy_translate "(record [x=2;y=3;z=1], record [dx=3;dy=4])"\n# Outputs: {z = 1 , y = 7 , x = 5}\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"You have to understand that ",Object(o.b)("inlineCode",{parentName:"p"},"p")," has not been changed by the functional\nupdate: a nameless new version of it has been created and returned by\nthe block-less function."))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("p",null,"The syntax for the functional updates of record in CameLIGO follows\nthat of OCaml:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=records2",group:"records2"}),"type point = {x : int; y : int; z : int}\ntype vector = {dx : int; dy : int}\n\nlet origin : point = {x = 0; y = 0; z = 0}\n\nlet xy_translate (p, vec : point * vector) : point =\n  {p with x = p.x + vec.dx; y = p.y + vec.dy}\n")),Object(o.b)("p",null,"You can call the function ",Object(o.b)("inlineCode",{parentName:"p"},"xy_translate")," defined above by running the\nfollowing command of the shell:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/maps-records/record_update.mligo\nxy_translate "({x=2;y=3;z=1}, {dx=3;dy=4})"\n# Outputs: {z = 1 , y = 7 , x = 5}\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"You have to understand that ",Object(o.b)("inlineCode",{parentName:"p"},"p")," has not been changed by the\nfunctional update: a nameless new version of it has been created and\nreturned."))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("p",null,"The syntax for the functional updates of record in ReasonLIGO follows\nthat of ReasonML:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=records2",group:"records2"}),"type point = {x : int, y : int, z : int};\ntype vector = {dx : int, dy : int};\n\nlet origin : point = {x : 0, y : 0, z : 0};\n\nlet xy_translate = ((p, vec) : (point, vector)) : point =>\n  {...p, x : p.x + vec.dx, y : p.y + vec.dy};\n")),Object(o.b)("p",null,"You can call the function ",Object(o.b)("inlineCode",{parentName:"p"},"xy_translate")," defined above by running the\nfollowing command of the shell:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/maps-records/record_update.religo\nxy_translate "({x:2,y:3,z:1}, {dx:3,dy:4})"\n# Outputs: {z = 1 , y = 7 , x = 5}\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"You have to understand that ",Object(o.b)("inlineCode",{parentName:"p"},"p")," has not been changed by the\nfunctional update: a nameless new version of it has been created and\nreturned."))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("p",null,"The syntax for the functional updates of record in JsLIGO:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=records2",group:"records2"}),"type point = {x: int, y: int, z: int};\ntype vector = {dx: int, dy: int};\n\nlet origin: point = {x: 0, y: 0, z: 0};\n\nlet xy_translate = ([p, vec]: [point, vector]): point =>\n  ({...p, x: p.x + vec.dx, y: p.y + vec.dy});\n")),Object(o.b)("p",null,"You can call the function ",Object(o.b)("inlineCode",{parentName:"p"},"xy_translate")," defined above by running the\nfollowing command of the shell:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/maps-records/record_update.jsligo\nxy_translate "({x:2,y:3,z:1}, {dx:3,dy:4})"\n# Outputs: {z = 1 , y = 7 , x = 5}\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"You have to understand that ",Object(o.b)("inlineCode",{parentName:"p"},"p")," has not been changed by the\nfunctional update: a nameless new version of it has been created and\nreturned."))),Object(o.b)("h4",{id:"nested-updates"},"Nested updates"),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("p",null,"A unique feature of LIGO is the ability to perform nested updates on records."),Object(o.b)("p",null,"For example if you have the following record structure:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),"type color is\n| Blue\n| Green\n\ntype preferences is record [\n  color : color;\n  other : int;\n]\n\ntype account is record [\n  id : int;\n  preferences : preferences;\n]\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("p",null,"A unique feature of LIGO is the ability to perform nested updates on records."),Object(o.b)("p",null,"For example if you have the following record structure:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),"type color =\n  Blue\n| Green\n\ntype preferences = {\n  color : color;\n  other : int;\n}\n\ntype account = {\n  id: int;\n  preferences: preferences;\n}\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("p",null,"A unique feature of LIGO is the ability to perform nested updates on records."),Object(o.b)("p",null,"For example if you have the following record structure:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),"type color =\n  Blue\n| Green;\n\ntype preferences = {\n  color : color,\n  other : int\n}\n\ntype account = {\n  id : int,\n  preferences : preferences\n}\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("p",null,"A unique feature of LIGO is the ability to perform nested updates on records.\nJsLIGO however does not support the specialised syntax as the other syntaxes.\nThe following however also does the trick."),Object(o.b)("p",null,"For example if you have the following record structure:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),'type color =\n  ["Blue"]\n| ["Green"];\n\ntype preferences = {\n  color: color,\n  other: int\n};\n\ntype account = {\n  id: int,\n  preferences: preferences\n};\n'))),Object(o.b)("p",null,"You can update the nested record with the following code:"),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo"}),"\nfunction change_color_preference (var account : account; const color : color ) : account is\n  block {\n      account := account with record [preferences.color = color]\n  } with account\n\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo"}),"let change_color_preference (account : account) (color : color) : account =\n  { account with preferences.color = color }\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo"}),"let change_color_preference = (account : account, color : color): account =>\n  { ...account, preferences.color: color };\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo"}),"let change_color_preference = (account : account, color : color): account =>\n  ({ ...account, preferences: {...account.preferences, color: color }});\n"))),Object(o.b)("p",null,"Note that all the records in the path will get updated. In this example that's\n",Object(o.b)("inlineCode",{parentName:"p"},"account")," and ",Object(o.b)("inlineCode",{parentName:"p"},"preferences"),"."),Object(o.b)("p",null,"You can call the function ",Object(o.b)("inlineCode",{parentName:"p"},"change_color_preference")," defined above by running the\nfollowing command:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call gitlab-pages/docs/language-basics/src/maps-records/record_nested_update.ligo \nchange_color_preference "(record [id=1001; preferences=record [color=Blue; other=1]], Green)"\n# Outputs: record[id -> 1001 , preferences -> record[color -> Green(unit) , other -> 1]]\n')),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("h3",{id:"record-patches"},"Record Patches"),Object(o.b)("p",null,"Another way to understand what it means to update a record value is to\nmake sure that any further reference to the value afterwards will\nexhibit the modification. This is called a ",Object(o.b)("inlineCode",{parentName:"p"},"patch")," and this is only\npossible in PascaLIGO, because a patch is an ",Object(o.b)("em",{parentName:"p"},"instruction"),", therefore\nwe can only use it in a block. Similarly to a ",Object(o.b)("em",{parentName:"p"},"functional update"),', a\npatch takes a record to be updated and a record with a subset of the\nfields to update, then applies the latter to the former (hence the\nname "patch").'),Object(o.b)("p",null,"Let us consider defining a function that translates three-dimensional\npoints on a plane."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=records3",group:"records3"}),"type point is record [x : int; y : int; z : int]\ntype vector is record [dx : int; dy : int]\n\nfunction xy_translate (var p : point; const vec : vector) : point is\n  block {\n    patch p with record [x = p.x + vec.dx];\n    patch p with record [y = p.y + vec.dy]\n  } with p\n")),Object(o.b)("p",null,"You can call the function ",Object(o.b)("inlineCode",{parentName:"p"},"xy_translate")," defined above by running the\nfollowing command of the shell:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/maps-records/record_patch.ligo\nxy_translate "(record [x=2;y=3;z=1], record [dx=3;dy=4])"\n# Outputs: {z = 1 , y = 7 , x = 5}\n')),Object(o.b)("p",null,"Of course, we can actually translate the point with only one ",Object(o.b)("inlineCode",{parentName:"p"},"patch"),",\nas the previous example was meant to show that, after the first patch,\nthe value of ",Object(o.b)("inlineCode",{parentName:"p"},"p")," indeed changed. So, a shorter version would be"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=records4",group:"records4"}),"type point is record [x : int; y : int; z : int]\ntype vector is record [dx : int; dy : int]\n\nfunction xy_translate (var p : point; const vec : vector) : point is\n  block {\n    patch p with record [x = p.x + vec.dx; y = p.y + vec.dy]\n  } with p\n")),Object(o.b)("p",null,"You can call the new function ",Object(o.b)("inlineCode",{parentName:"p"},"xy_translate")," defined above by running the\nfollowing command of the shell:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/maps-records/record_patch2.ligo\nxy_translate "(record [x=2;y=3;z=1], record [dx=3;dy=4])"\n# Outputs: {z = 1 , y = 7 , x = 5}\n')),Object(o.b)("p",null,"Record patches can actually be simulated with functional updates. All\nwe have to do is ",Object(o.b)("em",{parentName:"p"},"declare a new record value with the same name as the\none we want to update")," and use a functional update, like so:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=records5",group:"records5"}),"type point is record [x : int; y : int; z : int]\ntype vector is record [dx : int; dy : int]\n\nfunction xy_translate (var p : point; const vec : vector) : point is\n  block {\n    const p : point = p with record [x = p.x + vec.dx; y = p.y + vec.dy]\n  } with p\n")),Object(o.b)("p",null,"You can call the new function ",Object(o.b)("inlineCode",{parentName:"p"},"xy_translate")," defined above by running the\nfollowing command of the shell:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),'ligo evaluate-call\ngitlab-pages/docs/language-basics/src/maps-records/record_simu.ligo\nxy_translate "(record [x=2;y=3;z=1], record [dx=3;dy=4])"\n# Outputs: {z = 1 , y = 7 , x = 5}\n')),Object(o.b)("p",null,"The hiding of a variable by another (here ",Object(o.b)("inlineCode",{parentName:"p"},"p"),") is called ",Object(o.b)("inlineCode",{parentName:"p"},"shadowing"),".")),Object(o.b)("h3",{id:"comparison"},"Comparison"),Object(o.b)("p",null,"Record types are comparable, which allows to check for equality and\nuse records as key in sets or maps. By default, the ordering of\nrecords is ",Object(o.b)("strong",{parentName:"p"},"undefined and implementation dependent"),". Ultimately, the\norder is determined by the translated Michelson type. When using the\n",Object(o.b)("inlineCode",{parentName:"p"},"[@layout:comb]")," attribute, fields are translated in their order in\nthe record, and records are then ordered with lexicographic ordering."),Object(o.b)("h2",{id:"maps"},"Maps"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Maps")," are a data structure which associate values of the same type to\nvalues of the same type. The former are called ",Object(o.b)("em",{parentName:"p"},"key")," and the latter\n",Object(o.b)("em",{parentName:"p"},"values"),". Together they make up a ",Object(o.b)("em",{parentName:"p"},"binding"),". An additional requirement\nis that the type of the keys must be ",Object(o.b)("em",{parentName:"p"},"comparable"),", in the Michelson\nsense."),Object(o.b)("h3",{id:"declaring-a-map"},"Declaring a Map"),Object(o.b)("p",null,"Here is how a custom map from addresses to a pair of integers is\ndefined."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),"type move is int * int\ntype register is map (address, move)\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),"type move = int * int\ntype register = (address, move) map\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),"type move = (int, int);\ntype register = map (address, move);\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),"type move = [int, int];\ntype register = map<address, move>;\n"))),Object(o.b)("h3",{id:"creating-an-empty-map"},"Creating an Empty Map"),Object(o.b)("p",null,"Here is how to create an empty map."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),"const empty : register = map []\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),"let empty : register = Map.empty\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),"let empty : register = Map.empty\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),"let empty: register = Map.empty;\n"))),Object(o.b)("h3",{id:"creating-a-non-empty-map"},"Creating a Non-empty Map"),Object(o.b)("p",null,"And here is how to create a non-empty map value:"),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),'const moves : register =\n  map [\n    ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address) -> (1,2);\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) -> (0,3)]\n')),Object(o.b)("p",null,"Notice the ",Object(o.b)("inlineCode",{parentName:"p"},"->")," between the key and its value and ",Object(o.b)("inlineCode",{parentName:"p"},";")," to separate\nindividual map entries. The annotated value ",Object(o.b)("inlineCode",{parentName:"p"},'("<string value>" :\naddress)')," means that we cast a string into an address. Also, ",Object(o.b)("inlineCode",{parentName:"p"},"map")," is\na keyword.")),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),'let moves : register =\n  Map.literal [\n    (("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address), (1,2));\n    (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address), (0,3))]\n')),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Map.literal")," predefined function builds a map from a list of\nkey-value pair tuples, ",Object(o.b)("inlineCode",{parentName:"p"},"(<key>, <value>)"),".  Note also the ",Object(o.b)("inlineCode",{parentName:"p"},";")," to\nseparate individual map entries.  ",Object(o.b)("inlineCode",{parentName:"p"},'("<string value>": address)')," means\nthat we type-cast a string into an address. ")),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),'let moves : register =\n  Map.literal ([\n    ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address, (1,2)),\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address, (0,3))]);\n')),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Map.literal")," predefined function builds a map from a list of\nkey-value pair tuples, ",Object(o.b)("inlineCode",{parentName:"p"},"(<key>, <value>)"),".  Note also the ",Object(o.b)("inlineCode",{parentName:"p"},",")," to\nseparate individual map entries.  ",Object(o.b)("inlineCode",{parentName:"p"},'("<string value>": address)')," means\nthat we type-cast a string into an address. ")),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),'let moves : register =\n  Map.literal (list([\n    ["tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" as address, [1,2]],\n    ["tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, [0,3]]]));\n')),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Map.literal")," predefined function builds a map from a list of\nkey-value pair tuples, ",Object(o.b)("inlineCode",{parentName:"p"},"[<key>, <value>]"),".  Note also the ",Object(o.b)("inlineCode",{parentName:"p"},",")," to\nseparate individual map entries.  ",Object(o.b)("inlineCode",{parentName:"p"},'"<string value>" as address')," means\nthat we type-cast a string into an address.")),Object(o.b)("h3",{id:"accessing-map-bindings"},"Accessing Map Bindings"),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("p",null,"In PascaLIGO, we can use the postfix ",Object(o.b)("inlineCode",{parentName:"p"},"[]")," operator to read the ",Object(o.b)("inlineCode",{parentName:"p"},"move"),"\nvalue associated to a given key (",Object(o.b)("inlineCode",{parentName:"p"},"address")," here) in the register. Here\nis an example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),'const my_balance : option (move) =\n  moves [("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address)]\n'))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),'let my_balance : move option =\n  Map.find_opt ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) moves\n'))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),'let my_balance : option (move) =\n  Map.find_opt (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address), moves);\n'))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),'let my_balance: option<move> =\n  Map.find_opt("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, moves);\n'))),Object(o.b)("p",null,"Notice how the value we read is an optional value: this is to force\nthe reader to account for a missing key in the map. This requires\n",Object(o.b)("em",{parentName:"p"},"pattern matching"),"."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),'function force_access (const key : address; const moves : register) : move is\n  case moves[key] of\n    Some (move) -> move\n  | None -> (failwith ("No move.") : move)\n  end\n'))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),'let force_access (key, moves : address * register) : move =\n  match Map.find_opt key moves with\n    Some move -> move\n  | None -> (failwith "No move." : move)\n'))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),'let force_access = ((key, moves) : (address, register)) : move => {\n  switch (Map.find_opt (key, moves)) {\n  | Some (move) => move\n  | None => (failwith ("No move.") : move)\n  }\n};\n'))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),'let force_access = ([key, moves]: [address, register]): move => {\n  return match(Map.find_opt (key, moves), {\n   Some: (move: register) => move,\n   None: () => (failwith("No move.") as move)\n  });\n};\n'))),Object(o.b)("h3",{id:"updating-a-map"},"Updating a Map"),Object(o.b)("p",null,"Given a map, we may want to add a new binding, remove one, or modify\none by changing the value associated to an already existing key. All\nthose operations are called ",Object(o.b)("em",{parentName:"p"},"updates"),"."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("p",null,"The values of a PascaLIGO map can be updated using the usual\nassignment syntax ",Object(o.b)("inlineCode",{parentName:"p"},"<map variable>[<key>] := <new value>"),". Let us\nconsider an example."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),'function assign (var m : register) : register is\n  block {\n    m [("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN": address)] := (4,9)\n  } with m\n')),Object(o.b)("p",null,"If multiple bindings need to be updated, PascaLIGO offers a ",Object(o.b)("em",{parentName:"p"},"patch\ninstruction")," for maps, similar to that for records."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),'function assignments (var m : register) : register is\n  block {\n    patch m with map [\n      ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) -> (4,9);\n      ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address) -> (1,2)\n    ]\n  } with m\n')),Object(o.b)("p",null,"See further for the removal of bindings.")),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("p",null,"We can update a binding in a map in CameLIGO by means of the\n",Object(o.b)("inlineCode",{parentName:"p"},"Map.update")," built-in function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),'let assign (m : register) : register =\n  Map.update\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) (Some (4,9)) m\n')),Object(o.b)("p",null,"Notice the optional value ",Object(o.b)("inlineCode",{parentName:"p"},"Some (4,9)")," instead of ",Object(o.b)("inlineCode",{parentName:"p"},"(4,9)"),". If we had\nuse ",Object(o.b)("inlineCode",{parentName:"p"},"None")," instead, that would have meant that the binding is removed."),Object(o.b)("p",null,"As a particular case, we can only add a key and its associated value."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),'let add (m : register) : register =\n  Map.add\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) (4,9) m\n'))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("p",null,"We can update a binding in a map in ReasonLIGO by means of the\n",Object(o.b)("inlineCode",{parentName:"p"},"Map.update")," built-in function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),'let assign = (m : register) : register =>\n  Map.update\n    (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address), Some ((4,9)), m);\n')),Object(o.b)("p",null,"Notice the optional value ",Object(o.b)("inlineCode",{parentName:"p"},"Some (4,9)")," instead of ",Object(o.b)("inlineCode",{parentName:"p"},"(4,9)"),". If we used\n",Object(o.b)("inlineCode",{parentName:"p"},"None")," instead that would have meant that the binding is removed."),Object(o.b)("p",null,"As a particular case, we can only add a key and its associated value."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),'let add = (m : register) : register =>\n  Map.add\n    (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address), (4,9), m);\n'))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("p",null,"We can update a binding in a map in JsLIGO by means of the\n",Object(o.b)("inlineCode",{parentName:"p"},"Map.update")," built-in function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),'let assign = (m: register): register =>\n  Map.update\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, Some ([4, 9]), m);\n')),Object(o.b)("p",null,"Notice the optional value ",Object(o.b)("inlineCode",{parentName:"p"},"Some ([4,9])")," instead of ",Object(o.b)("inlineCode",{parentName:"p"},"[4, 9]"),". If we used\n",Object(o.b)("inlineCode",{parentName:"p"},"None")," instead that would have meant that the binding is removed."),Object(o.b)("p",null,"As a particular case, we can only add a key and its associated value."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),'let add = (m: register): register =>\n  Map.add\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, [4, 9], m);\n'))),Object(o.b)("p",null,"To remove a binding from a map, we need its key."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("p",null,"In PascaLIGO, there is a special instruction to remove a binding from\na map."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),"function delete (const key : address; var moves : register) : register is\n  block {\n    remove key from map moves\n  } with moves\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("p",null,"In CameLIGO, we use the predefined function ",Object(o.b)("inlineCode",{parentName:"p"},"Map.remove")," as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),"let delete (key, moves : address * register) : register =\n  Map.remove key moves\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("p",null,"In ReasonLIGO, we use the predefined function ",Object(o.b)("inlineCode",{parentName:"p"},"Map.remove")," as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),"let delete = ((key, moves) : (address, register)) : register =>\n  Map.remove (key, moves);\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("p",null,"In JsLIGO, we use the predefined function ",Object(o.b)("inlineCode",{parentName:"p"},"Map.remove")," as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),"let delete = ([key, moves]: [address, register]): register =>\n  Map.remove(key, moves);\n"))),Object(o.b)("h3",{id:"functional-iteration-over-maps"},"Functional Iteration over Maps"),Object(o.b)("p",null,"A ",Object(o.b)("em",{parentName:"p"},"functional iterator")," is a function that traverses a data structure\nand calls in turn a given function over the elements of that structure\nto compute some value. Another approach is possible in PascaLIGO:\n",Object(o.b)("em",{parentName:"p"},"loops")," (see the relevant section)."),Object(o.b)("p",null,"There are three kinds of functional iterations over LIGO maps: the\n",Object(o.b)("em",{parentName:"p"},"iterated operation"),", the ",Object(o.b)("em",{parentName:"p"},"map operation")," (not to be confused with the\n",Object(o.b)("em",{parentName:"p"},"map data structure"),") and the ",Object(o.b)("em",{parentName:"p"},"fold operation"),"."),Object(o.b)("h4",{id:"iterated-operation-over-maps"},"Iterated Operation over Maps"),Object(o.b)("p",null,"The first, the ",Object(o.b)("em",{parentName:"p"},"iterated operation"),", is an iteration over the map with\nno return value: its only use is to produce side-effects. This can be\nuseful if, for example you would like to check that each value inside\nof a map is within a certain range and fail with an error otherwise."),Object(o.b)("p",null,"The predefined functional iterator implementing the iterated operation\nover maps is called ",Object(o.b)("inlineCode",{parentName:"p"},"Map.iter"),". In the following example, the register\nof moves is iterated to check that the start of each move is above\n",Object(o.b)("inlineCode",{parentName:"p"},"3"),"."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),'function iter_op (const m : register) : unit is\n  block {\n    function iterated (const i : address; const j : move) : unit is\n      if j.1 > 3 then Unit else (failwith ("Below range.") : unit)\n  } with Map.iter (iterated, m)\n'))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),"let iter_op (m : register) : unit =\n  let predicate = fun (i,j : address * move) -> assert (j.0 > 3)\n  in Map.iter predicate m\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),"let iter_op = (m : register) : unit => {\n  let predicate = ((i,j) : (address, move)) => assert (j[0] > 3);\n  Map.iter (predicate, m);\n};\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),"let iter_op = (m: register): unit => {\n  let predicate = ([i, j]: [address, move]): unit => assert(j[0] > 3);\n  Map.iter(predicate, m);\n};\n"))),Object(o.b)("h4",{id:"map-operations-over-maps"},"Map Operations over Maps"),Object(o.b)("p",null,"We may want to change all the bindings of a map by applying to them a\nfunction. This is called a ",Object(o.b)("em",{parentName:"p"},"map operation"),", not to be confused with\nthe map data structure. The predefined functional iterator\nimplementing the map operation over maps is called ",Object(o.b)("inlineCode",{parentName:"p"},"Map.map"),". In the\nfollowing example, we add ",Object(o.b)("inlineCode",{parentName:"p"},"1")," to the ordinate of the moves in the\nregister."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),"function map_op (const m : register) : register is\n  block {\n    function increment (const i : address; const j : move) : move is\n      (j.0, j.1 + 1)\n  } with Map.map (increment, m)\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),"let map_op (m : register) : register =\n  let increment = fun (i,j : address * move) -> j.0, j.1 + 1\n  in Map.map increment m\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),"let map_op = (m : register) : register => {\n  let increment = ((i,j): (address, move)) => (j[0], j[1] + 1);\n  Map.map (increment, m);\n};\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),"let map_op = (m: register): register => {\n  let increment = ([i, j]: [address, move]): [int, int] => [j[0], j[1] + 1];\n  return Map.map(increment, m);\n};\n"))),Object(o.b)("h4",{id:"folded-operations-over-maps"},"Folded Operations over Maps"),Object(o.b)("p",null,"A ",Object(o.b)("em",{parentName:"p"},"folded operation")," is the most general of iterations. The folded\nfunction takes two arguments: an ",Object(o.b)("em",{parentName:"p"},"accumulator")," and the structure\n",Object(o.b)("em",{parentName:"p"},"element")," at hand, with which it then produces a new accumulator. This\nenables having a partial result that becomes complete when the\ntraversal of the data structure is over."),Object(o.b)("p",null,"The predefined functional iterator implementing the folded operation\nover maps is called ",Object(o.b)("inlineCode",{parentName:"p"},"Map.fold")," and is used as follows."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=maps",group:"maps"}),"function fold_op (const m : register) : int is\n  block {\n    function folded (const i : int; const j : address * move) : int is\n      i + j.1.1\n  } with Map.fold (folded, m, 5)\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=maps",group:"maps"}),"let fold_op (m : register) : int =\n  let folded = fun (i,j : int * (address * move)) -> i + j.1.1\n  in Map.fold folded m 5\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=maps",group:"maps"}),"let fold_op = (m : register) : int => {\n  let folded = ((i,j): (int, (address, move))) => i + j[1][1];\n  Map.fold (folded, m, 5);\n};\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=maps",group:"maps"}),"let fold_op = (m: register): int => {\n  let folded = ([i, j]: [int, [address, move]]): int => i + j[1][1];\n  return Map.fold(folded, m, 5);\n};\n"))),Object(o.b)("h2",{id:"big-maps"},"Big Maps"),Object(o.b)("p",null,"Ordinary maps are fine for contracts with a finite lifespan or a\nbounded number of users. For many contracts however, the intention is\nto have a map holding ",Object(o.b)("em",{parentName:"p"},"many")," entries, potentially millions of\nthem. The cost of loading those entries into the environment each time\na user executes the contract would eventually become too expensive\nwere it not for ",Object(o.b)("em",{parentName:"p"},"big maps"),". Big maps are a data structure offered by\nMichelson which handles the scaling concerns for us. In LIGO, the\ninterface for big maps is analogous to the one used for ordinary maps."),Object(o.b)("h3",{id:"declaring-a-map-1"},"Declaring a Map"),Object(o.b)("p",null,"Here is how we define a big map:"),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=big_maps",group:"big_maps"}),"type move is int * int\ntype register is big_map (address, move)\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"}),"type move = int * int\ntype register = (address, move) big_map\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=big_maps",group:"big_maps"}),"type move = (int, int);\ntype register = big_map (address, move);\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"}),"type move = [int, int];\ntype register = big_map<address, move>;\n"))),Object(o.b)("h3",{id:"creating-an-empty-big-map"},"Creating an Empty Big Map"),Object(o.b)("p",null,"Here is how to create an empty big map."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=big_maps",group:"big_maps"}),"const empty : register = big_map []\n"))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"}),"let empty : register = Big_map.empty\n"))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=big_maps",group:"big_maps"}),"let empty : register = Big_map.empty\n"))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"}),"let empty: register = Big_map.empty;\n"))),Object(o.b)("h3",{id:"creating-a-non-empty-map-1"},"Creating a Non-empty Map"),Object(o.b)("p",null,"And here is how to create a non-empty map value:"),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=big_maps",group:"big_maps"}),'const moves : register =\n  big_map [\n    ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address) -> (1,2);\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) -> (0,3)]\n')),Object(o.b)("p",null,"Notice the right arrow ",Object(o.b)("inlineCode",{parentName:"p"},"->")," between the key and its value and the\nsemicolon separating individual map entries. The value annotation\n",Object(o.b)("inlineCode",{parentName:"p"},'("<string value>" : address)')," means that we cast a string into an\naddress. --\x3e")),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"}),'let moves : register =\n  Big_map.literal [\n    (("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address), (1,2));\n    (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address), (0,3))]\n')),Object(o.b)("p",null,"The predefined function ",Object(o.b)("inlineCode",{parentName:"p"},"Big_map.literal")," constructs a big map from a\nlist of key-value pairs ",Object(o.b)("inlineCode",{parentName:"p"},"(<key>, <value>)"),". Note also the semicolon\nseparating individual map entries.  The annotated value ",Object(o.b)("inlineCode",{parentName:"p"},'("<string>\nvalue>" : address)')," means that we cast a string into an address.")),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=big_maps",group:"big_maps"}),'let moves : register =\n  Big_map.literal ([\n    ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address, (1,2)),\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address, (0,3))]);\n')),Object(o.b)("p",null,"The predefined function ",Object(o.b)("inlineCode",{parentName:"p"},"Big_map.literal")," constructs a big map from a\nlist of key-value pairs ",Object(o.b)("inlineCode",{parentName:"p"},"(<key>, <value>)"),". Note also the semicolon\nseparating individual map entries.  The annotated value ",Object(o.b)("inlineCode",{parentName:"p"},'("<string>\nvalue>" : address)')," means that we cast a string into an address.")),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"}),'let moves : register =\n  Big_map.literal (list([\n    ["tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" as address, [1, 2]],\n    ["tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, [0, 3]]]));\n')),Object(o.b)("p",null,"The predefined function ",Object(o.b)("inlineCode",{parentName:"p"},"Big_map.literal")," constructs a big map from a\nlist of key-value pairs ",Object(o.b)("inlineCode",{parentName:"p"},"[<key>, <value>]"),". Note also the semicolon\nseparating individual map entries.  The annotated value ",Object(o.b)("inlineCode",{parentName:"p"},'("<string>\nvalue>" as address)')," means that we cast a string into an address.")),Object(o.b)("h3",{id:"accessing-values"},"Accessing Values"),Object(o.b)("p",null,"If we want to access a move from our ",Object(o.b)("inlineCode",{parentName:"p"},"register")," above, we can use the\npostfix ",Object(o.b)("inlineCode",{parentName:"p"},"[]")," operator to read the associated ",Object(o.b)("inlineCode",{parentName:"p"},"move")," value. However,\nthe value we read is an optional value (in our case, of type ",Object(o.b)("inlineCode",{parentName:"p"},"option\n(move)"),"), to account for a missing key. Here is an example:"),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=big_maps",group:"big_maps"}),'const my_balance : option (move) =\n  moves [("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address)]\n'))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"}),'let my_balance : move option =\n  Big_map.find_opt ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) moves\n'))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=big_maps",group:"big_maps"}),'let my_balance : option (move) =\n  Big_map.find_opt ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address, moves);\n'))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"}),'let my_balance: option<move> =\n  Big_map.find_opt("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, moves);\n'))),Object(o.b)("h3",{id:"updating-big-maps"},"Updating Big Maps"),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("p",null,"The values of a PascaLIGO big map can be updated using the\nassignment syntax for ordinary maps"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=big_maps",group:"big_maps"}),'function assign (var m : register) : register is\n  block {\n    m [("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN": address)] := (4,9)\n  } with m\n')),Object(o.b)("p",null,"If multiple bindings need to be updated, PascaLIGO offers a ",Object(o.b)("em",{parentName:"p"},"patch\ninstruction")," for maps, similar to that for records."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=big_maps",group:"big_maps"}),'function assignments (var m : register) : register is\n  block {\n    patch m with map [\n      ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) -> (4,9);\n      ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address) -> (1,2)\n    ]\n  } with m\n'))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("p",null,"We can update a big map in CameLIGO using the ",Object(o.b)("inlineCode",{parentName:"p"},"Big_map.update"),"\nbuilt-in:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"}),'let updated_map : register =\n  Big_map.update\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) (Some (4,9)) moves\n'))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("p",null,"We can update a big map in ReasonLIGO using the ",Object(o.b)("inlineCode",{parentName:"p"},"Big_map.update"),"\nbuilt-in:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=big_maps",group:"big_maps"}),'let updated_map : register =\n  Big_map.update\n    (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN": address), Some ((4,9)), moves);\n'))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("p",null,"We can update a big map in JsLIGO using the ",Object(o.b)("inlineCode",{parentName:"p"},"Big_map.update"),"\nbuilt-in:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"}),'let updated_map: register =\n  Big_map.update\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, Some([4, 9]), moves);\n'))),Object(o.b)("h3",{id:"removing-bindings"},"Removing Bindings"),Object(o.b)("p",null,"Removing a binding in a map is done differently according to the LIGO\nsyntax."),Object(o.b)(s.b,{syntax:"pascaligo",mdxType:"Syntax"},Object(o.b)("p",null,"PascaLIGO features a special syntactic construct to remove bindings\nfrom maps, of the form ",Object(o.b)("inlineCode",{parentName:"p"},"remove <key> from map <map>"),". For example,"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-pascaligo",metastring:"group=big_maps",group:"big_maps"}),'function rem (var m : register) : register is\n  block {\n    remove ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN": address) from map moves\n  } with m\n\nconst updated_map : register = rem (moves)\n'))),Object(o.b)(s.b,{syntax:"cameligo",mdxType:"Syntax"},Object(o.b)("p",null,"In CameLIGO, the predefined function which removes a binding in a map\nis called ",Object(o.b)("inlineCode",{parentName:"p"},"Map.remove")," and is used as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"}),'let updated_map : register =\n  Map.remove ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN": address) moves\n'))),Object(o.b)(s.b,{syntax:"reasonligo",mdxType:"Syntax"},Object(o.b)("p",null,"In ReasonLIGO, the predefined function which removes a binding in a map\nis called ",Object(o.b)("inlineCode",{parentName:"p"},"Map.remove")," and is used as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reasonligo",metastring:"group=big_maps",group:"big_maps"}),'let updated_map : register =\n  Map.remove (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN": address), moves)\n'))),Object(o.b)(s.b,{syntax:"jsligo",mdxType:"Syntax"},Object(o.b)("p",null,"In JsLIGO, the predefined function which removes a binding in a map\nis called ",Object(o.b)("inlineCode",{parentName:"p"},"Map.remove")," and is used as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"}),'let updated_map: register =\n  Map.remove("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, moves);\n'))))}b.isMDXComponent=!0},457:function(e,a,t){"use strict";t.d(a,"a",(function(){return b})),t.d(a,"b",(function(){return g}));var n=t(0),r=t.n(n);function o(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function c(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach((function(a){o(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=r.a.createContext({}),l=function(e){var a=r.a.useContext(p),t=a;return e&&(t="function"==typeof e?e(a):c(c({},a),e)),t},b=function(e){var a=l(e.components);return r.a.createElement(p.Provider,{value:a},e.children)},m={inlineCode:"code",wrapper:function(e){var a=e.children;return r.a.createElement(r.a.Fragment,{},a)}},d=r.a.forwardRef((function(e,a){var t=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),b=l(t),d=n,g=b["".concat(s,".").concat(d)]||b[d]||m[d]||o;return t?r.a.createElement(g,c(c({ref:a},p),{},{components:t})):r.a.createElement(g,c({ref:a},p))}));function g(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var o=t.length,s=new Array(o);s[0]=d;var c={};for(var i in a)hasOwnProperty.call(a,i)&&(c[i]=a[i]);c.originalType=e,c.mdxType="string"==typeof e?e:n,s[1]=c;for(var p=2;p<o;p++)s[p]=t[p];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},458:function(e,a,t){"use strict";var n=t(0),r=t.n(n).a.createContext("pascaligo");a.a=r},459:function(e,a,t){"use strict";var n=t(0),r=t.n(n),o=t(458);t.d(a,"a",(function(){return o.a})),a.b=function(e){return r.a.createElement(o.a.Consumer,null,(function(a){return a===e.syntax?e.children:r.a.createElement(r.a.Fragment,null)}))}}}]);